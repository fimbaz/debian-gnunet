This is gnunet.info, produced by makeinfo version 6.5 from gnunet.texi.

Copyright © 2001-2018 GNUnet e.V.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled “GNU Free
Documentation License”.

   A copy of the license is also available from the Free Software
Foundation Web site at <http://www.gnu.org/licenses/fdl.html>.

   Alternately, this document is also available under the General Public
License, version 3 or later, as published by the Free Software
Foundation.  A copy of the license is included in the section entitled
“GNU General Public License”.

   A copy of the license is also available from the Free Software
Foundation Web site at <http://www.gnu.org/licenses/gpl.html>.
INFO-DIR-SECTION Networking
START-INFO-DIR-ENTRY
* GNUnet: (gnunet).       Framework for secure peer-to-peer networking
END-INFO-DIR-ENTRY


File: gnunet.info,  Node: Top,  Next: Preface,  Up: (dir)

Introduction
************

This document is the Reference Manual for GNUnet version 0.11.0pre66.

* Menu:


* Preface::                         Chapter 0
* Philosophy::                      About GNUnet
* GNUnet Installation Handbook::    How to install GNUnet
* Using GNUnet::                    Using GNUnet
* GNUnet Contributors Handbook::    Contributing to GNUnet
* GNUnet Developer Handbook::       Developing GNUnet
* GNU Free Documentation License::  The license of this manual
* GNU General Public License::      The license of this manual
* Concept Index::                   Concepts
* Programming Index::               Data types, functions, and variables

 — The Detailed Node Listing —

Preface

* About this book
* Introduction
* General Terminology::
* Typography::

Philosophy

* Design Goals::
* Security and Privacy::
* Versatility::
* Practicality::
* Key Concepts::
* Authentication::
* Accounting to Encourage Resource Sharing::
* Confidentiality::
* Anonymity::
* Deniability::
* Peer Identities::
* Zones in the GNU Name System (GNS Zones)::
* Egos::
* Backup of Identities and Egos::
* Revocation::

GNUnet Installation Handbook

* Dependencies::
* Pre-installation notes::
* Generic installation instructions::
* Build instructions for Ubuntu 12.04 using Git::
* Build instructions for software builds from source::
* Build Instructions for Microsoft Windows Platforms::
* Build instructions for Debian 7.5::
* Installing GNUnet from Git on Ubuntu 14.4::
* Build instructions for Debian 8::
* Outdated build instructions for previous revisions::
* The graphical configuration interface::
* How to start and stop a GNUnet peer::

Using GNUnet

* Checking the Installation::
* First steps - File-sharing::
* First steps - Using the GNU Name System::
* First steps - Using GNUnet Conversation::
* First steps - Using the GNUnet VPN::
* File-sharing::
* The GNU Name System::
* Using the Virtual Public Network::


GNUnet Contributors Handbook

* Contributing to GNUnet::
* Licenses of contributions::
* Copyright Assignment::
* Contributing to the Reference Manual::

GNUnet Developer Handbook

* Developer Introduction::
* Code overview::
* System Architecture::
* Subsystem stability::
* Naming conventions and coding style guide::
* Build-system::
* Developing extensions for GNUnet using the gnunet-ext template::
* Writing testcases::
* TESTING library::
* Performance regression analysis with Gauger::
* TESTBED Subsystem::
* libgnunetutil::
* Automatic Restart Manager (ARM)::
* TRANSPORT Subsystem::
* NAT library::
* Distance-Vector plugin::
* SMTP plugin::
* Bluetooth plugin::
* WLAN plugin::
* ATS Subsystem::
* CORE Subsystem::
* CADET Subsystem::
* NSE Subsystem::
* HOSTLIST Subsystem::
* IDENTITY Subsystem::
* NAMESTORE Subsystem::
* PEERINFO Subsystem::
* PEERSTORE Subsystem::
* SET Subsystem::
* STATISTICS Subsystem::
* Distributed Hash Table (DHT)::
* GNU Name System (GNS)::
* GNS Namecache::
* REVOCATION Subsystem::
* File-sharing (FS) Subsystem::
* REGEX Subsystem::



File: gnunet.info,  Node: Preface,  Next: Philosophy,  Prev: Top,  Up: Top

1 Preface
*********

This collection of manuals describes how to use GNUnet, a framework for
secure peer-to-peer networking with the high-level goal to provide a
strong foundation Free Software for a global, distributed network that
provides security and privacy.  GNUnet in that sense aims to replace the
current Internet protocol stack.  Along with an application for secure
publication of files, it has grown to include all kinds of basic
applications for the foundation of a new Internet.

* Menu:

* About this book::
* Introduction::
* Project governance::
* General Terminology::
* Typography::


File: gnunet.info,  Node: About this book,  Next: Introduction,  Up: Preface

1.1 About this book
===================

The books (described as “book” or “books” in the following) bundled as
the “GNUnet Reference Manual” are based on the historic work of all
contributors to GNUnet’s documentation.  The documentation existed in
various formats before it came to be in the format you are currently
reading.  It is our hope that the content is described in a way that
does not require any academic background, although some concepts will
require further reading.

   Our (long-term) goal with these books is to keep them self-contained.
If you see references to Wikipedia and other external sources (except
for our academic papers) it means that we are working on a solution to
describe the explanations found there which fits our use-case and
licensing.

   The first chapter (“Preface”) as well as the the second chapter
(“Philosophy”) give an introduction to GNUnet as a project, what GNUnet
tries to achieve.


File: gnunet.info,  Node: Introduction,  Next: Project governance,  Prev: About this book,  Up: Preface

1.2 Introduction
================

GNUnet in its current version is the result of almost 20 years of work
from many contributors.  So far, most contributions were made by
volunteers or people paid to do fundamental research.  Thus, significant
parts of the software lack a reasonable degree of professionalism in its
implementation.  Furthermore, we are aware of a significant number of
existing bugs and critical design flaws, as some unfortunate early
design decisions remain to be rectified.  There are still known open
problems; GNUnet remains an active research project.

   The project was started in 2001 when some initial ideas for improving
Freenet’s file-sharing turned out to be too radical to be easily
realized within the scope of the existing Freenet project.  We lost our
first contributor on 11.9.2001 as the contributor realized that privacy
may help terrorists.  The rest of the team concluded that it was now
even more important to fight for civil liberties.  The first release was
called “GNet” – already with the name GNUnet in mind, but without the
blessing of GNU we did not dare to call it GNUnet immediately.  A few
months after the first release we contacted the GNU project, happily
agreed to their governance model and became an official GNU package.

   Within the first year, we created GNU libextractor, a helper library
for meta data extraction which has been used by a few other projects as
well.  2003 saw the emergence of pluggable transports, the ability for
GNUnet to use different mechanisms for communication, starting with TCP,
UDP and SMTP (support for the latter was later dropped due to a lack of
maintenance).  In 2005, the project first started to evolve beyond the
original file-sharing application with a first simple P2P chat.  In
2007, we created GNU libmicrohttpd to support a pluggable transport
based on HTTP. In 2009, the architecture was radically modularized into
the multi-process system that exists today.  Coincidentally, the first
version of the ARM service was implemented a day before systemd was
announced.  From 2009 to 2014 work progressed rapidly thanks to a
significant research grant from the Deutsche Forschungsgesellschaft.
This resulted in particular in the creation of the R5N DHT, CADET, ATS
and the GNU Name System.  In 2010, GNUnet was selected as the basis for
the SecuShare online social network, resutling in a significant growth
of the core team.  In 2013, we launched GNU Taler to address the
challenge of convenient and privacy-preserving online payments.  In
2015, the pEp project announced that they will use GNUnet as the
technology for their meta-data protection layer, ultimately resulting in
GNUnet e.V. entering into a formal long-term collaboration with the pEp
foundation.  In 2016, Taler Systems SA, a first startup using GNUnet
technology, was founded with support from the community.

   GNUnet is not merely a technical project, but also a political
mission: like the GNU project as a whole, we are writing software to
achieve political goals with a focus on the human right of informational
self-determination.  Putting users in control of their computing has
been the core driver of the GNU project.  With GNUnet we are focusing on
informational self-determination for collaborative computing and
communication over networks.

   The Internet is shaped as much by code and protocols as by its
associated political processes (IETF, ICANN, IEEE, etc.), and its flaws
are similarly not limited to the protocol design.  Thus, technical
excellence by itself will not suffice to create a better network.  We
also need to build a community that is wise, humble and has a sense of
humor to achieve our goal to create a technical foundation for a society
we would like to live in.


File: gnunet.info,  Node: Project governance,  Next: General Terminology,  Prev: Introduction,  Up: Preface

1.3 Project governance
======================

GNUnet, like the GNU project and many other free software projects,
follows the governance model of a benevolent dictator.  This means that
ultimately, the GNU project appoints the GNU maintainer and can overrule
decisions made by the GNUnet maintainer.  Similarly, the GNUnet
maintainer can overrule any decisions made by individual developers.
Still, in practice neither has happened in the last 20 years, and we
hope to keep it that way.

   The GNUnet project is supported by GNUnet e.V., a German association
where any developer can become a member.  GNUnet e.V. servers as a legal
entity to hold the copyrights to GNUnet.  GNUnet e.V. may also choose to
pay for project resources, and can collect donations.  GNUnet e.V. may
also choose to adjust the license of the software (with the constraint
that it has to remain free software).


File: gnunet.info,  Node: General Terminology,  Next: Typography,  Prev: Project governance,  Up: Preface

1.4 General Terminology
=======================

In the following manual we may use words that can not be found in the
Appendix.  Since we want to keep the manual selfcontained, we will
explain words here.


File: gnunet.info,  Node: Typography,  Prev: General Terminology,  Up: Preface

1.5 Typography
==============

When giving examples for commands, shell prompts are used to show if the
command should/can be issued as root, or if "normal" user privileges are
sufficient.  We use a ‘#’ for root’s shell prompt, a ‘%’ for users’
shell prompt, assuming they use the C-shell or tcsh and a ‘$’ for bourne
shell and derivatives.


File: gnunet.info,  Node: Philosophy,  Next: GNUnet Installation Handbook,  Prev: Preface,  Up: Top

2 Philosophy
************

The foremost goal of the GNUnet project is to become a widely used,
reliable, open, non-discriminating, egalitarian, unconstrained and
censorship-resistant system of free information exchange.  We value free
speech above state secrets, law-enforcement or intellectual monopoly.
GNUnet is supposed to be an anarchistic network, where the only
limitation for participants (devices or people making use of the
network, in the following sometimes called peers) is that they must
contribute enough back to the network such that their resource
consumption does not have a significant impact on other users.  GNUnet
should be more than just another file-sharing network.  The plan is to
offer many other services and in particular to serve as a development
platform for the next generation of Internet Protocols.

* Menu:

* Design Goals::
* Security and Privacy::
* Versatility::
* Practicality::
* Key Concepts::


File: gnunet.info,  Node: Design Goals,  Next: Security and Privacy,  Up: Philosophy

2.1 Design Goals
================

These are the core GNUnet design goals, in order of relative importance:

   • GNUnet must be implemented as Free Software
     (https://www.gnu.org/philosophy/free-sw.html) (1)
   • GNUnet must only disclose the minimal amount of information
     necessary.
   • GNUnet must be fully distributed and survive Byzantine failures
     (https://en.wikipedia.org/wiki/Byzantine_fault_tolerance) (2) at
     any position in the network.
   • GNUnet must make it explicit to the user which entities are
     considered to be trustworthy when establishing secured
     communications.
   • GNUnet must use compartmentalization to protect sensitive
     information.
   • GNUnet must be open and permit new peers to join.
   • GNUnet must be self-organizing and not depend on administrators.
   • GNUnet must support a diverse range of applications and devices.
   • The GNUnet architecture must be cost effective.
   • GNUnet must provide incentives for peers to contribute more
     resources than they consume.

   ---------- Footnotes ----------

   (1) This means that you you have the four essential freedoms: to run
the program, to study and change the program in source code form, to
redistribute exact copies, and to distribute modified versions.  Refer
to https://www.gnu.org/philosophy/free-sw.html
(https://www.gnu.org/philosophy/free-sw.html)

   (2) https://en.wikipedia.org/wiki/Byzantine_fault_tolerance
(https://en.wikipedia.org/wiki/Byzantine_fault_tolerance)


File: gnunet.info,  Node: Security and Privacy,  Next: Versatility,  Prev: Design Goals,  Up: Philosophy

2.2 Security and Privacy
========================

GNUnet’s primary design goals are to protect the privacy of its users
and to guard itself against attacks or abuse.  GNUnet does not have any
mechanisms to control, track or censor users.  Instead, the GNUnet
protocols aim to make it as hard as possible to find out what is
happening on the network or to disrupt operations.


File: gnunet.info,  Node: Versatility,  Next: Practicality,  Prev: Security and Privacy,  Up: Philosophy

2.3 Versatility
===============

We call GNUnet a peer-to-peer framework because we want to support many
different forms of peer-to-peer applications.  GNUnet uses a plugin
architecture to make the system extensible and to encourage code reuse.
While the first versions of the system only supported anonymous
file-sharing, other applications are being worked on and more will
hopefully follow in the future.  A powerful synergy regarding anonymity
services is created by a large community utilizing many diverse
applications over the same software infrastructure.  The reason is that
link encryption hides the specifics of the traffic for non-participating
observers.  This way, anonymity can get stronger with additional
(GNUnet) traffic, even if the additional traffic is not related to
anonymous communication.  Increasing anonymity is the primary reason why
GNUnet is developed to become a peer-to-peer framework where many
applications share the lower layers of an increasingly complex protocol
stack.  If merging traffic to hinder traffic analysis was not important,
we could have just developed a dozen stand-alone applications and a few
shared libraries.


File: gnunet.info,  Node: Practicality,  Next: Key Concepts,  Prev: Versatility,  Up: Philosophy

2.4 Practicality
================

GNUnet allows participants to trade various amounts of security in
exchange for increased efficiency.  However, it is not possible for any
user’s security and efficiency requirements to compromise the security
and efficiency of any other user.

   For GNUnet, efficiency is not paramount.  If there were a more secure
and still practical approach, we would choose to take the more secure
alternative.  ‘telnet’ is more efficient than ‘ssh’, yet it is obsolete.
Hardware gets faster, and code can be optimized.  Fixing security issues
as an afterthought is much harder.

   While security is paramount, practicability is still a requirement.
The most secure system is always the one that nobody can use.
Similarly, any anonymous system that is extremely inefficient will only
find few users.  However, good anonymity requires a large and diverse
user base.  Since individual security requirements may vary, the only
good solution here is to allow individuals to trade-off security and
efficiency.  The primary challenge in allowing this is to ensure that
the economic incentives work properly.  In particular, this means that
it must be impossible for a user to gain security at the expense of
other users.  Many designs (e.g.  anonymity via broadcast) fail to give
users an incentive to choose a less secure but more efficient mode of
operation.  GNUnet should avoid where ever possible to rely on protocols
that will only work if the participants are benevolent.  While some
designs have had widespread success while relying on parties to observe
a protocol that may be sub-optimal for the individuals (e.g.  TCP
Nagle), a protocol that ensures that individual goals never conflict
with the goals of the group is always preferable.


File: gnunet.info,  Node: Key Concepts,  Prev: Practicality,  Up: Philosophy

2.5 Key Concepts
================

In this section, the fundamental concepts of GNUnet are explained.  Most
of them are also described in our research papers.  First, some of the
concepts used in the GNUnet framework are detailed.  The second part
describes concepts specific to anonymous file-sharing.

* Menu:

* Authentication::
* Accounting to Encourage Resource Sharing::
* Confidentiality::
* Anonymity::
* Deniability::
* Peer Identities::
* Zones in the GNU Name System (GNS Zones)::
* Egos::


File: gnunet.info,  Node: Authentication,  Next: Accounting to Encourage Resource Sharing,  Up: Key Concepts

2.5.1 Authentication
--------------------

Almost all peer-to-peer communications in GNUnet are between mutually
authenticated peers.  The authentication works by using ECDHE, that is a
DH (Diffie—Hellman) key exchange using ephemeral eliptic curve
cryptography.  The ephemeral ECC (Eliptic Curve Cryptography) keys are
signed using ECDSA (ECDSA (http://en.wikipedia.org/wiki/ECDSA)). The
shared secret from ECDHE is used to create a pair of session keys (using
HKDF) which are then used to encrypt the communication between the two
peers using both 256-bit AES (Advanced Encryption Standard) and 256-bit
Twofish (with independently derived secret keys).  As only the two
participating hosts know the shared secret, this authenticates each
packet without requiring signatures each time.  GNUnet uses SHA-512
(Secure Hash Algorithm) hash codes to verify the integrity of messages.

   In GNUnet, the identity of a host is its public key.  For that
reason, man-in-the-middle attacks will not break the authentication or
accounting goals.  Essentially, for GNUnet, the IP of the host has
nothing to do with the identity of the host.  As the public key is the
only thing that truly matters, faking an IP, a port or any other
property of the underlying transport protocol is irrelevant.  In fact,
GNUnet peers can use multiple IPs (IPv4 and IPv6) on multiple ports — or
even not use the IP protocol at all (by running directly on layer 2).

   GNUnet uses a special type of message to communicate a binding
between public (ECC) keys to their current network address.  These
messages are commonly called ‘HELLO’s or ‘peer advertisements’.  They
contain the public key of the peer and its current network addresses for
various transport services.  A transport service is a special kind of
shared library that provides (possibly unreliable, out-of-order) message
delivery between peers.  For the UDP and TCP transport services, a
network address is an IP and a port.  GNUnet can also use other
transports (HTTP, HTTPS, WLAN, etc.)  which use various other forms of
addresses.  Note that any node can have many different active transport
services at the same time, and each of these can have a different
addresses.  Binding messages expire after at most a week (the timeout
can be shorter if the user configures the node appropriately).  This
expiration ensures that the network will eventually get rid of outdated
advertisements.  (1)

   ---------- Footnotes ----------

   (1) Ronaldo A. Ferreira, Christian Grothoff, and Paul Ruth.  A
Transport Layer Abstraction for Peer-to-Peer Networks Proceedings of the
3rd International Symposium on Cluster Computing and the Grid (GRID
2003), 2003.
(https://gnunet.org/git/bibliography.git/plain/docs/transport.pdf
(https://gnunet.org/git/bibliography.git/plain/docs/transport.pdf))


File: gnunet.info,  Node: Accounting to Encourage Resource Sharing,  Next: Confidentiality,  Prev: Authentication,  Up: Key Concepts

2.5.2 Accounting to Encourage Resource Sharing
----------------------------------------------

Most distributed P2P networks suffer from a lack of defenses or
precautions against attacks in the form of freeloading.  While the
intentions of an attacker and a freeloader are different, their effect
on the network is the same; they both render it useless.  Most simple
attacks on networks such as ‘Gnutella’ involve flooding the network with
traffic, particularly with queries that are, in the worst case,
multiplied by the network.

   In order to ensure that freeloaders or attackers have a minimal
impact on the network, GNUnet’s file-sharing implementation (‘FS’ tries
to distinguish good (contributing) nodes from malicious (freeloading)
nodes.  In GNUnet, every file-sharing node keeps track of the behavior
of every other node it has been in contact with.  Many requests
(depending on the application) are transmitted with a priority (or
importance) level.  That priority is used to establish how important the
sender believes this request is.  If a peer responds to an important
request, the recipient will increase its trust in the responder: the
responder contributed resources.  If a peer is too busy to answer all
requests, it needs to prioritize.  For that, peers do not take the
priorities of the requests received at face value.  First, they check
how much they trust the sender, and depending on that amount of trust
they assign the request a (possibly lower) effective priority.  Then,
they drop the requests with the lowest effective priority to satisfy
their resource constraints.  This way, GNUnet’s economic model ensures
that nodes that are not currently considered to have a surplus in
contributions will not be served if the network load is high.  (1)

   ---------- Footnotes ----------

   (1) Christian Grothoff.  An Excess-Based Economic Model for Resource
Allocation in Peer-to-Peer Networks.  Wirtschaftsinformatik, June 2003.
(https://gnunet.org/git/bibliography.git/plain/docs/ebe.pdf
(https://gnunet.org/git/bibliography.git/plain/docs/ebe.pdf))


File: gnunet.info,  Node: Confidentiality,  Next: Anonymity,  Prev: Accounting to Encourage Resource Sharing,  Up: Key Concepts

2.5.3 Confidentiality
---------------------

Adversaries (malicious, bad actors) outside of GNUnet are not supposed
to know what kind of actions a peer is involved in.  Only the specific
neighbor of a peer that is the corresponding sender or recipient of a
message may know its contents, and even then application protocols may
place further restrictions on that knowledge.  In order to ensure
confidentiality, GNUnet uses link encryption, that is each message
exchanged between two peers is encrypted using a pair of keys only known
to these two peers.  Encrypting traffic like this makes any kind of
traffic analysis much harder.  Naturally, for some applications, it may
still be desirable if even neighbors cannot determine the concrete
contents of a message.  In GNUnet, this problem is addressed by the
specific application-level protocols.  See for example the following
sections *note Anonymity::, *note How file-sharing achieves Anonymity::,
and *note Deniability::.


File: gnunet.info,  Node: Anonymity,  Next: Deniability,  Prev: Confidentiality,  Up: Key Concepts

2.5.4 Anonymity
---------------

* Menu:

* How file-sharing achieves Anonymity::

Providing anonymity for users is the central goal for the anonymous
file-sharing application.  Many other design decisions follow in the
footsteps of this requirement.  Anonymity is never absolute.  While
there are various scientific metrics(1) that can help quantify the level
of anonymity that a given mechanism provides, there is no such thing as
"complete anonymity".  GNUnet’s file-sharing implementation allows users
to select for each operation (publish, search, download) the desired
level of anonymity.  The metric used is the amount of cover traffic
available to hide the request.  While this metric is not as good as, for
example, the theoretical metric given in scientific metrics(2), it is
probably the best metric available to a peer with a purely local view of
the world that does not rely on unreliable external information.  The
default anonymity level is ‘1’, which uses anonymous routing but imposes
no minimal requirements on cover traffic.  It is possible to forego
anonymity when this is not required.  The anonymity level of ‘0’ allows
GNUnet to use more efficient, non-anonymous routing.

   ---------- Footnotes ----------

   (1) Claudia Díaz, Stefaan Seys, Joris Claessens, and Bart Preneel.
Towards measuring anonymity.  2002.
(https://gnunet.org/git/bibliography.git/plain/docs/article-89.pdf
(https://gnunet.org/git/bibliography.git/plain/docs/article-89.pdf))

   (2) likewise


File: gnunet.info,  Node: How file-sharing achieves Anonymity,  Up: Anonymity

2.5.4.1 How file-sharing achieves Anonymity
...........................................

Contrary to other designs, we do not believe that users achieve strong
anonymity just because their requests are obfuscated by a couple of
indirections.  This is not sufficient if the adversary uses traffic
analysis.  The threat model used for anonymous file sharing in GNUnet
assumes that the adversary is quite powerful.  In particular, we assume
that the adversary can see all the traffic on the Internet.  And while
we assume that the adversary can not break our encryption, we assume
that the adversary has many participating nodes in the network and that
it can thus see many of the node-to-node interactions since it controls
some of the nodes.

   The system tries to achieve anonymity based on the idea that users
can be anonymous if they can hide their actions in the traffic created
by other users.  Hiding actions in the traffic of other users requires
participating in the traffic, bringing back the traditional technique of
using indirection and source rewriting.  Source rewriting is required to
gain anonymity since otherwise an adversary could tell if a message
originated from a host by looking at the source address.  If all packets
look like they originate from one node, the adversary can not tell which
ones originate from that node and which ones were routed.  Note that in
this mindset, any node can decide to break the source-rewriting paradigm
without violating the protocol, as this only reduces the amount of
traffic that a node can hide its own traffic in.

   If we want to hide our actions in the traffic of other nodes, we must
make our traffic indistinguishable from the traffic that we route for
others.  As our queries must have us as the receiver of the reply
(otherwise they would be useless), we must put ourselves as the receiver
of replies that actually go to other hosts; in other words, we must
indirect replies.  Unlike other systems, in anonymous file-sharing as
implemented on top of GNUnet we do not have to indirect the replies if
we don’t think we need more traffic to hide our own actions.

   This increases the efficiency of the network as we can indirect less
under higher load.(1)

   ---------- Footnotes ----------

   (1) Krista Bennett and Christian Grothoff.  GAP — practical anonymous
networking.  In Proceedings of Designing Privacy Enhancing Technologies,
2003.  (https://gnunet.org/git/bibliography.git/plain/docs/aff.pdf
(https://gnunet.org/git/bibliography.git/plain/docs/aff.pdf))


File: gnunet.info,  Node: Deniability,  Next: Peer Identities,  Prev: Anonymity,  Up: Key Concepts

2.5.5 Deniability
-----------------

Even if the user that downloads data and the server that provides data
are anonymous, the intermediaries may still be targets.  In particular,
if the intermediaries can find out which queries or which content they
are processing, a strong adversary could try to force them to censor
certain materials.

   With the file-encoding used by GNUnet’s anonymous file-sharing, this
problem does not arise.  The reason is that queries and replies are
transmitted in an encrypted format such that intermediaries cannot tell
what the query is for or what the content is about.  Mind that this is
not the same encryption as the link-encryption between the nodes.
GNUnet has encryption on the network layer (link encryption,
confidentiality, authentication) and again on the application layer
(provided by ‘gnunet-publish’, ‘gnunet-download’, ‘gnunet-search’ and
‘gnunet-gtk’).  (1)

   ---------- Footnotes ----------

   (1) Christian Grothoff, Krista Grothoff, Tzvetan Horozov, and Jussi
T. Lindgren.  An Encoding for Censorship-Resistant Sharing.  2009.
(https://gnunet.org/git/bibliography.git/plain/docs/ecrs.pdf
(https://gnunet.org/git/bibliography.git/plain/docs/ecrs.pdf))


File: gnunet.info,  Node: Peer Identities,  Next: Zones in the GNU Name System (GNS Zones),  Prev: Deniability,  Up: Key Concepts

2.5.6 Peer Identities
---------------------

Peer identities are used to identify peers in the network and are unique
for each peer.  The identity for a peer is simply its public key, which
is generated along with a private key the peer is started for the first
time.  While the identity is binary data, it is often expressed as ASCII
string.  For example, the following is a peer identity as you might see
it in various places:

     UAT1S6PMPITLBKSJ2DGV341JI6KF7B66AC4JVCN9811NNEGQLUN0

You can find your peer identity by running ‘gnunet-peerinfo -s’.


File: gnunet.info,  Node: Zones in the GNU Name System (GNS Zones),  Next: Egos,  Prev: Peer Identities,  Up: Key Concepts

2.5.7 Zones in the GNU Name System (GNS Zones)
----------------------------------------------

GNS(1) zones are similar to those of DNS zones, but instead of a
hierarchy of authorities to governing their use, GNS zones are
controlled by a private key.  When you create a record in a DNS zone,
that information is stored in your nameserver.  Anyone trying to resolve
your domain then gets pointed (hopefully) by the centralised authority
to your nameserver.  Whereas GNS, being fully decentralized by design,
stores that information in DHT. The validity of the records is assured
cryptographically, by signing them with the private key of the
respective zone.

   Anyone trying to resolve records in a zone of your domain can then
verify the signature of the records they get from the DHT and be assured
that they are indeed from the respective zone.  To make this work, there
is a 1:1 correspondence between zones and their public-private key
pairs.  So when we talk about the owner of a GNS zone, that’s really the
owner of the private key.  And a user accessing a zone needs to somehow
specify the corresponding public key first.

   ---------- Footnotes ----------

   (1) Matthias Wachs, Martin Schanzenbach, and Christian Grothoff.  A
Censorship-Resistant, Privacy-Enhancing and Fully Decentralized Name
System.  In proceedings of 13th International Conference on Cryptology
and Network Security (CANS 2014).  2014.
https://gnunet.org/git/bibliography.git/plain/docs/gns2014wachs.pdf
(https://gnunet.org/git/bibliography.git/plain/docs/gns2014wachs.pdf)


File: gnunet.info,  Node: Egos,  Prev: Zones in the GNU Name System (GNS Zones),  Up: Key Concepts

2.5.8 Egos
----------

Egos are your "identities" in GNUnet.  Any user can assume multiple
identities, for example to separate their activities online.  Egos can
correspond to "pseudonyms" or "real-world identities".  Technically an
ego is first of all a key pair of a public- and private-key.


File: gnunet.info,  Node: GNUnet Installation Handbook,  Next: Using GNUnet,  Prev: Philosophy,  Up: Top

3 GNUnet Installation Handbook
******************************

This handbook describes how to install (build, setup, compile) and setup
(configure, start) GNUnet 0.11.0pre66.  After following these
instructions you should be able to install and then start
user-interfaces to interact with the network.

   Note: This manual is far from complete, and we welcome contributions,
be it in the form of new chapters or insightful comments.

* Menu:

* Dependencies::
* Pre-installation notes::
* Generic installation instructions::
* Build instructions for Ubuntu 12.04 using Git::
* Build instructions for software builds from source::
* Build Instructions for Microsoft Windows Platforms::
* Build instructions for Debian 7.5::
* Installing GNUnet from Git on Ubuntu 14.4::
* Build instructions for Debian 8::
* Build instructions for macOS::
* Outdated build instructions for previous revisions::
* The graphical configuration interface::
* How to start and stop a GNUnet peer::


File: gnunet.info,  Node: Dependencies,  Next: Pre-installation notes,  Up: GNUnet Installation Handbook

3.1 Dependencies
================

This section lists the various known dependencies for GNUnet
0.11.0pre66.  Suggestions for missing dependencies or wrong version
numbers are welcome.

* Menu:

* External dependencies::
* Optional dependencies::
* Internal dependencies::


File: gnunet.info,  Node: External dependencies,  Next: Optional dependencies,  Up: Dependencies

3.1.1 External dependencies
---------------------------

These packages must be installed before a typical GNUnet installation
can be performed:

   • autoconf
   • automake
   • pkg-config
   • libltdl
   • gstreamer
   • gst-plugins-base
   • perl
   • python (only 2.7 supported)(1)
   • jansson
   • nss
   • glib
   • gmp
   • bluez
   • miniupnpc
   • gettext
   • which
   • texinfo ≥ 5.2
   • GNU libmicrohttpd ≥ 0.9.30 (2)
   • GNU libextractor ≥ 1.0
   • GNU libtool ≥ 2.2
   • GNU libunistring ≥ 0.9.1.1
   • GNU libidn ≥ 1.0.0
   • GNU libgcrypt (https://gnupg.org/software/libgcrypt/) ≥ 1.6.0
     (https://gnupg.org/ftp/gcrypt/libgcrypt/)
   • GnuTLS (https://gnutls.org/) ≥ 3.2.7 (3)
   • gnURL (https://gnunet.org/gnurl) libgnurl ≥ 7.34.0 (4)
   • libglpk ≥ 4.45
   • OpenSSL (http://www.openssl.org/) ≥ 1.0
   • TeX Live ≥ 2012, optional (for gnunet-bcd)
   • Texinfo ≥ 5.2 (for documentation)
   • libsqlite ≥ 3.8.0 (5)
   • zlib

   ---------- Footnotes ----------

   (1) tests and gnunet-qr

   (2) We recommend to build it with a GnuTLS version that was
configured with libunbound

   (3) We recommend to compile with libunbound for DANE support; GnuTLS
also requires GNU nettle 2.7 (update: GnuTLS 3.2.7 appears NOT to work
against GNU nettle > 2.7, due to some API updatings done by nettle.
Thus it should be compiled against nettle 2.7 and, in case you get some
error on the reference to ‘rpl_strerror’ being undefined, follow the
instructions on this
(http://lists.gnupg.org/pipermail/gnutls-devel/2013-November/006588.html)
post (and the link inside it)).

   (4) must be compiled after ‘GnuTLS’

   (5) (note that the code will compile and often work with lower
version numbers, but you may get subtle bugs with respect to quota
management in certain rare cases); alternatively, MySQL or Postgres can
also be installed, but those databases will require more complex
configurations (not recommended for first-time users)


File: gnunet.info,  Node: Optional dependencies,  Next: Internal dependencies,  Prev: External dependencies,  Up: Dependencies

3.1.2 Optional dependencies
---------------------------

These applications must be installed for various experimental or
otherwise optional features such as ‘gnunet-conversation’, and
‘gnunet-conversation-gtk’ (most of these features are only build if you
configure GNUnet with ‘--enable-experimental’):

   • libpulse ≥ 2.0, optional (for ‘gnunet-conversation’)
   • libopus ≥ 1.0.1, optional (for ‘gnunet-conversation’)
   • libogg ≥ 1.3.0, optional (for ‘gnunet-conversation’)
   • libnss contained ‘certool’ binary, optional for convenient
     installation of the GNS proxy.
   • python-zbar ≥ 0.10, optional (for ‘gnunet-qr’)
   • Gtk+ ≥ 3.0, optional (for ‘gnunet-gtk’)
   • libgladeui (must match Gtk+ version), optional (for ‘gnunet-gtk’)
   • libqrencode ≥ 3.0, optional (for ‘gnunet-namestore-gtk’)
   • libpbc ≥ 0.5.14, optional for Attribute-Based Encryption and
     Identity Provider functionality
   • libgabe (https://github.com/schanzen/libgabe), optional for
     Attribute-Based Encryption and Identity Provider functionality


File: gnunet.info,  Node: Internal dependencies,  Prev: Optional dependencies,  Up: Dependencies

3.1.3 Internal dependencies
---------------------------

This section tries to give an overview of what processes a typical
GNUnet peer running a particular application would consist of.  All of
the processes listed here should be automatically started by ‘gnunet-arm
-s’.  The list is given as a rough first guide to users for failure
diagnostics.  Ideally, end-users should never have to worry about these
internal dependencies.

   In terms of internal dependencies, a minimum file-sharing system
consists of the following GNUnet processes (in order of dependency):

   • gnunet-service-arm
   • gnunet-service-resolver (required by all)
   • gnunet-service-statistics (required by all)
   • gnunet-service-peerinfo
   • gnunet-service-transport (requires peerinfo)
   • gnunet-service-core (requires transport)
   • gnunet-daemon-hostlist (requires core)
   • gnunet-daemon-topology (requires hostlist, peerinfo)
   • gnunet-service-datastore
   • gnunet-service-dht (requires core)
   • gnunet-service-identity
   • gnunet-service-fs (requires identity, mesh, dht, datastore, core)

A minimum VPN system consists of the following GNUnet processes (in
order of dependency):

   • gnunet-service-arm
   • gnunet-service-resolver (required by all)
   • gnunet-service-statistics (required by all)
   • gnunet-service-peerinfo
   • gnunet-service-transport (requires peerinfo)
   • gnunet-service-core (requires transport)
   • gnunet-daemon-hostlist (requires core)
   • gnunet-service-dht (requires core)
   • gnunet-service-mesh (requires dht, core)
   • gnunet-service-dns (requires dht)
   • gnunet-service-regex (requires dht)
   • gnunet-service-vpn (requires regex, dns, mesh, dht)

A minimum GNS system consists of the following GNUnet processes (in
order of dependency):

   • gnunet-service-arm
   • gnunet-service-resolver (required by all)
   • gnunet-service-statistics (required by all)
   • gnunet-service-peerinfo
   • gnunet-service-transport (requires peerinfo)
   • gnunet-service-core (requires transport)
   • gnunet-daemon-hostlist (requires core)
   • gnunet-service-dht (requires core)
   • gnunet-service-mesh (requires dht, core)
   • gnunet-service-dns (requires dht)
   • gnunet-service-regex (requires dht)
   • gnunet-service-vpn (requires regex, dns, mesh, dht)
   • gnunet-service-identity
   • gnunet-service-namestore (requires identity)
   • gnunet-service-gns (requires vpn, dns, dht, namestore, identity)


File: gnunet.info,  Node: Pre-installation notes,  Next: Generic installation instructions,  Prev: Dependencies,  Up: GNUnet Installation Handbook

3.2 Pre-installation notes
==========================

Please note that in the code instructions for the installation, _#_
indicates commands run as privileged root user and _$_ shows commands
run as unprivileged ("normal") system user.


File: gnunet.info,  Node: Generic installation instructions,  Next: Build instructions for Ubuntu 12.04 using Git,  Prev: Pre-installation notes,  Up: GNUnet Installation Handbook

3.3 Generic installation instructions
=====================================

First, in addition to the GNUnet sources you might require downloading
the latest version of various dependencies, depending on how recent the
software versions in your distribution of GNU/Linux are.  Most
distributions do not include sufficiently recent versions of these
dependencies.  Thus, a typically installation on a "modern" GNU/Linux
distribution requires you to install the following dependencies (ideally
in this order):

   • libgpgerror and libgcrypt
   • libnettle and libunbound (possibly from distribution), GnuTLS
   • libgnurl (read the README)
   • GNU libmicrohttpd
   • GNU libextractor

   Make sure to first install the various mandatory and optional
dependencies including development headers from your distribution.

   Other dependencies that you should strongly consider to install is a
database (MySQL, sqlite or Postgres).  The following instructions will
assume that you installed at least sqlite.  For most distributions you
should be able to find pre-build packages for the database.  Again, make
sure to install the client libraries and the respective development
headers (if they are packaged separately) as well.

   You can find specific, detailed instructions for installing of the
dependencies (and possibly the rest of the GNUnet installation) in the
platform-specific descriptions, which can be found in the Index.  Please
consult them now.  If your distribution is not listed, please study
*note Build instructions for Debian 8::, the build instructions for
Debian stable, carefully as you try to install the dependencies for your
own distribution.  Contributing additional instructions for further
platforms is always appreciated.  Please take in mind that operating
system development tends to move at a rather fast speed.  Due to this
you should be aware that some of the instructions could be outdated by
the time you are reading this.  If you find a mistake, please tell us
about it (or even better: send a patch to the documentation to fix it!).

   Before proceeding further, please double-check the dependency list.
Note that in addition to satisfying the dependencies, you might have to
make sure that development headers for the various libraries are also
installed.  There maybe files for other distributions, or you might be
able to find equivalent packages for your distribution.

   While it is possible to build and install GNUnet without having root
access, we will assume that you have full control over your system in
these instructions.  First, you should create a system user _gnunet_ and
an additional group _gnunetdns_.  On the GNU/Linux distributions Debian
and Ubuntu, type:

     # adduser --system --home /var/lib/gnunet --group \
     --disabled-password gnunet
     # addgroup --system gnunetdns

On other Unixes and GNU systems, this should have the same effect:

     # useradd --system --groups gnunet --home-dir /var/lib/gnunet
     # addgroup --system gnunetdns

   Now compile and install GNUnet using:

     $ tar xvf gnunet-0.11.0pre66.tar.gz
     $ cd gnunet-0.11.0pre66
     $ ./configure --with-sudo=sudo --with-nssdir=/lib
     $ make
     $ sudo make install

   If you want to be able to enable DEBUG-level log messages, add
‘--enable-logging=verbose’ to the end of the ‘./configure’ command.
‘DEBUG’-level log messages are in English only and should only be useful
for developers (or for filing really detailed bug reports).

   Finally, you probably want to compile ‘gnunet-gtk’, which includes
‘gnunet-setup’ (a graphical tool for GNUnet configuration) and
‘gnunet-fs-gtk’ (a graphical tool for GNUnet file-sharing):

     $ tar xvf gnunet-gtk-0.11.0pre66.tar.gz
     $ cd gnunet-gtk-0.11.0pre66
     $ ./configure --with-gnunet=/usr/local/
     $ make
     $ sudo make install
     $ cd ..
     # just to be safe run this:
     $ sudo ldconfig

Next, edit the file ‘/etc/gnunet.conf’ to contain the following:

     [arm]
     SYSTEM_ONLY = YES
     USER_ONLY = NO

You may need to update your ‘ld.so’ cache to include files installed in
‘/usr/local/lib’:

     # ldconfig

Then, switch from user ‘root’ to user ‘gnunet’ to start the peer:

     # su -s /bin/sh - gnunet
     $ gnunet-arm -c /etc/gnunet.conf -s

   You may also want to add the last line in the gnunet user’s ‘crontab’
prefixed with ‘@reboot’ so that it is executed whenever the system is
booted:

     @reboot /usr/local/bin/gnunet-arm -c /etc/gnunet.conf -s

This will only start the system-wide GNUnet services.  Type exit to get
back your root shell.  Now, you need to configure the per-user part.
For each $USER that should get access to GNUnet on the system, run:

     # adduser $USER gnunet

to allow them to access the system-wide GNUnet services.  Then, each
user should create a configuration file ‘~/.config/gnunet.conf’ with the
lines:

     [arm]
     SYSTEM_ONLY = NO
     USER_ONLY = YES
     DEFAULTSERVICES = gns

and start the per-user services using

     $ gnunet-arm -c ~/.config/gnunet.conf -s

Again, adding a ‘crontab’ entry to autostart the peer is advised:

     @reboot /usr/local/bin/gnunet-arm -c $HOME/.config/gnunet.conf -s

Note that some GNUnet services (such as SOCKS5 proxies) may need a
system-wide TCP port for each user.  For those services, systems with
more than one user may require each user to specify a different port
number in their personal configuration file.

   Finally, the user should perform the basic initial setup for the GNU
Name System (GNS) certificate authority.  This is done by running:

     $ gnunet-gns-proxy-setup-ca

The first generates the default zones, wheras the second setups the GNS
Certificate Authority with the user’s browser.  Now, to activate GNS in
the normal DNS resolution process, you need to edit your
‘/etc/nsswitch.conf’ where you should find a line like this:

     hosts: files mdns4_minimal [NOTFOUND=return] dns mdns4

The exact details may differ a bit, which is fine.  Add the text _"gns
[NOTFOUND=return]"_ after _"files"_.  Keep in mind that we included a
backslash ("\") here just for markup reasons.  You should write the text
below on one line and without the "\":

     hosts: files gns [NOTFOUND=return] mdns4_minimal \
     [NOTFOUND=return] dns mdns4

   You might want to make sure that ‘/lib/libnss_gns.so.2’ exists on
your system, it should have been created during the installation.


File: gnunet.info,  Node: Build instructions for Ubuntu 12.04 using Git,  Next: Build instructions for software builds from source,  Prev: Generic installation instructions,  Up: GNUnet Installation Handbook

3.4 Build instructions for Ubuntu 12.04 using Git
=================================================

* Menu:

* Install the required build tools::
* Install libgcrypt 1.6 and libgpg-error::
* Install gnutls with DANE support::
* Install libgnurl::
* Install libmicrohttpd from Git::
* Install libextractor from Git::
* Install GNUnet dependencies::
* Build GNUnet::
* Install the GNUnet-gtk user interface from Git::


File: gnunet.info,  Node: Install the required build tools,  Next: Install libgcrypt 1.6 and libgpg-error,  Up: Build instructions for Ubuntu 12.04 using Git

3.4.1 Install the required build tools
--------------------------------------

First, make sure Git is installed on your system:

     $ sudo apt-get install git

   Install the essential buildtools:

     $ sudo apt-get install automake autopoint autoconf libtool


File: gnunet.info,  Node: Install libgcrypt 1.6 and libgpg-error,  Next: Install gnutls with DANE support,  Prev: Install the required build tools,  Up: Build instructions for Ubuntu 12.04 using Git

3.4.2 Install libgcrypt 1.6 and libgpg-error
--------------------------------------------

*note generic source installation - libgpg-error::


File: gnunet.info,  Node: Install gnutls with DANE support,  Next: Install libgnurl,  Prev: Install libgcrypt 1.6 and libgpg-error,  Up: Build instructions for Ubuntu 12.04 using Git

3.4.3 Install gnutls with DANE support
--------------------------------------

   • *note generic source installation - nettle::
   • *note generic source installation - ldns::
   • *note generic source installation - libunbound/unbound::
   • *note generic source installation - gnutls::
   • *note generic source installation - libgcrypt::


File: gnunet.info,  Node: Install libgnurl,  Next: Install libmicrohttpd from Git,  Prev: Install gnutls with DANE support,  Up: Build instructions for Ubuntu 12.04 using Git

3.4.4 Install libgnurl
----------------------

Follow the *note generic source installation - libgnurl::.


File: gnunet.info,  Node: Install libmicrohttpd from Git,  Next: Install libextractor from Git,  Prev: Install libgnurl,  Up: Build instructions for Ubuntu 12.04 using Git

3.4.5 Install libmicrohttpd from Git
------------------------------------

     $ git clone https://gnunet.org/git/libmicrohttpd
     $ cd libmicrohttpd/
     $ ./bootstrap
     $ ./configure
     $ sudo make install ; cd ..


File: gnunet.info,  Node: Install libextractor from Git,  Next: Install GNUnet dependencies,  Prev: Install libmicrohttpd from Git,  Up: Build instructions for Ubuntu 12.04 using Git

3.4.6 Install libextractor from Git
-----------------------------------

Install libextractor dependencies:

     $ sudo apt-get install zlib1g-dev libgsf-1-dev libmpeg2-4-dev \
      libpoppler-dev libvorbis-dev libexiv2-dev libjpeg-dev \
      libtiff-dev libgif-dev libvorbis-dev libflac-dev libsmf-dev \
      g++

   Build libextractor:

     $ git clone https://gnunet.org/git/libextractor
     $ cd libextractor
     $ ./bootstrap
     $ ./configure
     $ sudo make install ; cd ..


File: gnunet.info,  Node: Install GNUnet dependencies,  Next: Build GNUnet,  Prev: Install libextractor from Git,  Up: Build instructions for Ubuntu 12.04 using Git

3.4.7 Install GNUnet dependencies
---------------------------------

     $ sudo apt-get install libidn11-dev libunistring-dev libglpk-dev \
      libpulse-dev libbluetooth-dev libsqlite-dev

   Install libopus:

     $ wget http://downloads.xiph.org/releases/opus/opus-1.1.tar.gz
     $ tar xf opus-1.1.tar.gz
     $ cd opus-1.1/
     $ ./configure
     $ sudo make install ; cd ..

   Choose one or more database backends:

   SQLite3:
     $ sudo apt-get install libsqlite3-dev
   MySQL:
     $ sudo apt-get install libmysqlclient-dev
   PostgreSQL:
     $ sudo apt-get install libpq-dev postgresql


File: gnunet.info,  Node: Build GNUnet,  Next: Install the GNUnet-gtk user interface from Git,  Prev: Install GNUnet dependencies,  Up: Build instructions for Ubuntu 12.04 using Git

3.4.8 Build GNUnet
------------------

* Menu:

* Configuring the installation path::
* Configuring the system::
* Installing components requiring sudo permission::
* Build::


File: gnunet.info,  Node: Configuring the installation path,  Next: Configuring the system,  Up: Build GNUnet

3.4.8.1 Configuring the installation path
.........................................

You can specify the location of the GNUnet installation by setting the
prefix when calling the configure script with ‘--prefix=DIRECTORY’

     $ export PATH=$PATH:DIRECTORY/bin


File: gnunet.info,  Node: Configuring the system,  Next: Installing components requiring sudo permission,  Prev: Configuring the installation path,  Up: Build GNUnet

3.4.8.2 Configuring the system
..............................

Please make sure NOW that you have created a user and group ’gnunet’ and
additionally a group ’gnunetdns’:

     $ sudo addgroup gnunet
     $ sudo addgroup gnunetdns
     $ sudo adduser gnunet

   Each GNUnet user should be added to the ’gnunet’ group (may require
fresh login to come into effect):

     $ sudo useradd -G  gnunet


File: gnunet.info,  Node: Installing components requiring sudo permission,  Next: Build,  Prev: Configuring the system,  Up: Build GNUnet

3.4.8.3 Installing components requiring sudo permission
.......................................................

Some components, like the nss plugin required for GNS, may require root
permissions.  To allow these few components to be installed use:

     $ ./configure --with-sudo


File: gnunet.info,  Node: Build,  Prev: Installing components requiring sudo permission,  Up: Build GNUnet

3.4.8.4 Build
.............

     $ git clone https://gnunet.org/git/gnunet/
     $ cd gnunet/
     $ ./bootstrap

   Use the required configure call including the optional installation
prefix ‘PREFIX’ or the sudo permissions:

     $ ./configure [ --with-sudo | --with-prefix=PREFIX ]

     $ make; sudo make install

   After installing it, you need to create an empty configuration file:

     mkdir ~/.gnunet; touch ~/.gnunet/gnunet.conf

   And finally you can start GNUnet with:

     $ gnunet-arm -s


File: gnunet.info,  Node: Install the GNUnet-gtk user interface from Git,  Prev: Build GNUnet,  Up: Build instructions for Ubuntu 12.04 using Git

3.4.9 Install the GNUnet-gtk user interface from Git
----------------------------------------------------

Install depencies:

     $ sudo apt-get install libgtk-3-dev libunique-3.0-dev libgladeui-dev \
      libqrencode-dev

   Build GNUnet (with an optional prefix) and execute:

     $ git clone https://gnunet.org/git/gnunet-gtk/
     $ cd gnunet-gtk/
     $ ./bootstrap
     $ ./configure [--prefix=PREFIX] --with-gnunet=DIRECTORY
     $ make; sudo make install


File: gnunet.info,  Node: Build instructions for software builds from source,  Next: Build Instructions for Microsoft Windows Platforms,  Prev: Build instructions for Ubuntu 12.04 using Git,  Up: GNUnet Installation Handbook

3.5 Build instructions for software builds from source
======================================================

This section describes software builds in case your operating system
lacks binary substitutes / binary builds for some dependencies of
GNUnet.  It is assumed that you have installed common build dependencies
and that these instructions are treated as generic without any debugging
help.  It is furthermore assumed that you use the release tarballs of
the software, installation from the respective version control sources
might differ in ways that are only minimal different (for example a
dependency on autotools etc).

* Menu:

* generic source installation - nettle::
* generic source installation - ldns::
* generic source installation - libunbound/unbound::
* generic source installation - libav::
* generic source installation - libextractor::
* generic source installation - libgpg-error::
* generic source installation - libgcrypt::
* generic source installation - gnutls::
* generic source installation - libmicrohttpd::
* generic source installation - libgnurl::


File: gnunet.info,  Node: generic source installation - nettle,  Next: generic source installation - ldns,  Up: Build instructions for software builds from source

3.5.1 generic source installation - nettle
------------------------------------------

     $ wget http://www.lysator.liu.se/~nisse/archive/nettle-2.7.1.tar.gz
     $ tar xf nettle-2.7.1.tar.gz
     $ cd nettle-2.7.1
     $ ./configure
     $ sudo make install ; cd ..


File: gnunet.info,  Node: generic source installation - ldns,  Next: generic source installation - libunbound/unbound,  Prev: generic source installation - nettle,  Up: Build instructions for software builds from source

3.5.2 generic source installation - ldns
----------------------------------------

     $ wget https://www.nlnetlabs.nl/downloads/ldns/ldns-1.6.16.tar.gz
     $ tar xf ldns-1.6.16.tar.gz
     $ cd ldns-1.6.16
     $ ./configure
     $ sudo make install ; cd ..


File: gnunet.info,  Node: generic source installation - libunbound/unbound,  Next: generic source installation - libav,  Prev: generic source installation - ldns,  Up: Build instructions for software builds from source

3.5.3 generic source installation - libunbound/unbound
------------------------------------------------------

     $ wget https://unbound.net/downloads/unbound-1.4.21.tar.gz
     $ tar xf unbound-1.4.21.tar.gz
     $ cd unbound-1.4.21
     $ ./configure
     $ sudo make install ; cd ..


File: gnunet.info,  Node: generic source installation - libav,  Next: generic source installation - libextractor,  Prev: generic source installation - libunbound/unbound,  Up: Build instructions for software builds from source

3.5.4 generic source installation - libav
-----------------------------------------

     $ wget https://libav.org/releases/libav-9.10.tar.xz
     $ cd libav-0.9 ; ./configure --enable-shared;
     $ make; sudo make install; cd ..


File: gnunet.info,  Node: generic source installation - libextractor,  Next: generic source installation - libgpg-error,  Prev: generic source installation - libav,  Up: Build instructions for software builds from source

3.5.5 generic source installation - libextractor
------------------------------------------------

     $ wget https://ftp.gnu.org/gnu/libextractor/libextractor-1.3.tar.gz
     $ tar xvf libextractor-1.3.tar.gz
     $ cd libextractor-1.3 ; ./configure;
     $ make ; sudo make install; cd ..


File: gnunet.info,  Node: generic source installation - libgpg-error,  Next: generic source installation - libgcrypt,  Prev: generic source installation - libextractor,  Up: Build instructions for software builds from source

3.5.6 generic source installation - libgpg-error
------------------------------------------------

     $ wget https://ftp.gnupg.org/gcrypt/libgpg-error/libgpg-error-1.12.tar.bz2
     $ tar xvf libgpg-error-1.12.tar.bz2
     $ cd libgpg-error-1.12; ./configure;
     $ make ; sudo make install; cd ..


File: gnunet.info,  Node: generic source installation - libgcrypt,  Next: generic source installation - gnutls,  Prev: generic source installation - libgpg-error,  Up: Build instructions for software builds from source

3.5.7 generic source installation - libgcrypt
---------------------------------------------

     $ wget https://ftp.gnupg.org/gcrypt/libgcrypt/libgcrypt-1.6.0.tar.bz2
     $ tar xvf libgcrypt-1.6.0.tar.bz2
     $ cd libgcrypt-1.6.0; ./configure --with-gpg-error-prefix=/usr/local;
     $ make ; sudo make install ; cd ..


File: gnunet.info,  Node: generic source installation - gnutls,  Next: generic source installation - libmicrohttpd,  Prev: generic source installation - libgcrypt,  Up: Build instructions for software builds from source

3.5.8 generic source installation - gnutls
------------------------------------------

     $ wget ftp://ftp.gnutls.org/gcrypt/gnutls/v3.2/gnutls-3.2.7.tar.xz
     $ tar xvf gnutls-3.2.7.tar.xz
     $ cd gnutls-3.2.7

If you want a GnuTLS with DANE functionality (recommended for GNUnet),
you have to compile it against libunbound.  Assuming that libunbound is
installed on your system:

     $ ./configure --enable-libdane

Note that the build system of GnuTLS should pick up libunbound without
the explicit mention of ‘--enable-libdane’.  If you don’t want libdane
support you should pass ‘--disable-libdane’ instead.

     $ ./configure
     $ make ; sudo make install ; cd ..


File: gnunet.info,  Node: generic source installation - libmicrohttpd,  Next: generic source installation - libgnurl,  Prev: generic source installation - gnutls,  Up: Build instructions for software builds from source

3.5.9 generic source installation - libmicrohttpd
-------------------------------------------------

     $ wget https://ftp.gnu.org/gnu/libmicrohttpd/libmicrohttpd-0.9.33.tar.gz
     $ tar xvf libmicrohttpd-0.9.33.tar.gz
     $ cd libmicrohttpd-0.9.33; ./configure;
     $ make ; sudo make install ; cd ..


File: gnunet.info,  Node: generic source installation - libgnurl,  Prev: generic source installation - libmicrohttpd,  Up: Build instructions for software builds from source

3.5.10 generic source installation - libgnurl
---------------------------------------------

Example installation of libgnurl version 7.57.0 from source.

     $ wget https://ftp.gnu.org/gnu/gnunet/gnurl-7.57.0.tar.xz
     $ wget https://ftp.gnu.org/gnu/gnunet/gnurl-7.57.0.tar.xz.sig
     $ gpg --verify gnurl-7.57.0.tar.xz.sig

If that command fails because you do not have the required public key,
then run this command to import it:

     $ gpg --keyserver pgp.mit.edu --recv-keys A88C8ADD129828D7EAC02E52E22F9BBFEE348588

and rerun the gpg –verify command.

     $ tar xvf gnurl-7.57.0.tar.xz
     $ cd gnurl-7.57.0
     $ ./configure --disable-ntlm-wb
     $ make ; sudo make install; cd ..

   You have now build and installed libgnurl from source.

* Menu:

* Fixing libgnurl build issues::


File: gnunet.info,  Node: Fixing libgnurl build issues,  Up: generic source installation - libgnurl

3.5.10.1 Fixing libgnurl build issues
.....................................

If you have to compile libgnurl from source (for example if the version
included in your distribution is too old or it’s not included at all)
you perhaps might get an error message while running the ‘configure’
script:

     $ configure
     ...
     checking for 64-bit curl_off_t data type... unknown
     checking for 32-bit curl_off_t data type... unknown
     checking for 16-bit curl_off_t data type... unknown
     configure: error: cannot find data type for curl_off_t.

Solution:

   Before running the ‘configure’ script, set:

     CFLAGS="-I. -I$BUILD_ROOT/include"


File: gnunet.info,  Node: Build Instructions for Microsoft Windows Platforms,  Next: Build instructions for Debian 7.5,  Prev: Build instructions for software builds from source,  Up: GNUnet Installation Handbook

3.6 Build Instructions for Microsoft Windows Platforms
======================================================

* Menu:

* Introduction to building on MS Windows::
* Requirements::
* Dependencies & Initial Setup::
* GNUnet Installation::
* Adjusting Windows for running and testing GNUnet::
* Building the GNUnet Installer::
* Using GNUnet with Netbeans on Windows::


File: gnunet.info,  Node: Introduction to building on MS Windows,  Next: Requirements,  Up: Build Instructions for Microsoft Windows Platforms

3.6.1 Introduction to building on MS Windows
--------------------------------------------

This document is a guide to building GNUnet and its dependencies on
Windows platforms.  GNUnet development is mostly done under GNU/Linux
and especially git checkouts may not build out of the box.  We regret
any inconvenience, and if you have problems, please report them.


File: gnunet.info,  Node: Requirements,  Next: Dependencies & Initial Setup,  Prev: Introduction to building on MS Windows,  Up: Build Instructions for Microsoft Windows Platforms

3.6.2 Requirements
------------------

The Howto is based upon a *Windows Server 2008 32bit* *Installation*,
*sbuild* and thus a MSYS+MinGW (http://www.mingw.org/wiki/MSYS)
(W32-GCC-Compiler-Suite + Unix-like Userland) installation.  sbuild is a
convenient set of scripts which creates a working msys/mingw
installation and installs most dependencies required for GNUnet.

   As of the point of the creation of these instructions, GNUnet
*requires* a Windows *Server* 2003 or newer for full feature support.
Windows Vista and later will also work, but *non-server version can not
run a VPN-Exit-Node* as the NAT features have been removed as of Windows
Vista.


File: gnunet.info,  Node: Dependencies & Initial Setup,  Next: GNUnet Installation,  Prev: Requirements,  Up: Build Instructions for Microsoft Windows Platforms

3.6.3 Dependencies & Initial Setup
----------------------------------

   • Install a fresh version of *Python 2.x*, even if you are using a
     x64-OS, install a 32-bit version for use with sbuild.  Python 3.0
     is currently incompatible.

   • Install your favorite git (http://code.google.com/p/tortoisegit/) &
     subversion (http://tortoisesvn.net/)-clients.

   • You will also need some archive-manager like 7zip
     (http://www.7-zip.org/).

   • Pull a copy of sbuild to a directory of your choice, which will be
     used in the remainder of this guide.  For now, we will use
     ‘c:\gnunet\sbuild\’

   • in ‘sbuild\src\mingw\mingw32-buildall.sh’, comment out the packages
     *gnunet-svn* and *gnunet-gtk-svn*, as we don’t want sbuild to
     compile/install those for us.

   • Follow LRN’s sbuild installation instructions.-

   Please note that sbuild may (or will most likely) fail during
installation, thus you really HAVE to *check the logfiles* created
during the installation process.  Certain packages may fail to build
initially due to missing dependencies, thus you may have to *substitute
those with binary-versions initially*.  Later on once dependencies are
satisfied you can re-build the newer package versions.

   *It is normal that you may have to repeat this step multiple times
and there is no uniform way to fix all compile-time issues, as the
build-process of many of the dependencies installed are rather unstable
on win32 and certain releases may not even compile at all.*

   Most dependencies for GNUnet have been set up by sbuild, thus we now
should add the ‘bin/’ directories in your new msys and mingw
installations to PATH. You will want to create a backup of your finished
msys-environment by now.


File: gnunet.info,  Node: GNUnet Installation,  Next: Adjusting Windows for running and testing GNUnet,  Prev: Dependencies & Initial Setup,  Up: Build Instructions for Microsoft Windows Platforms

3.6.4 GNUnet Installation
-------------------------

First, we need to launch our msys-shell, you can do this via

   ‘C:\gnunet\sbuild\msys\msys.bat’

   You might wish to take a look at this file and adjust some
login-parameters to your msys environment.

   Also, sbuild added two pointpoints to your msys-environment, though
those might remain invisible:

   • /mingw, which will mount your mingw-directory from sbuild/mingw and
     the other one is

   • /src which contains all the installation sources sbuild just
     compiled.

   Check out the current GNUnet sources (git HEAD) from the GNUnet
repository "gnunet.git", we will do this in your home directory:

   ‘git clone https://gnunet.org/git/gnunet/ ~/gnunet’

   Now, we will first need to bootstrap the checked out installation and
then configure it accordingly.

     cd ~/gnunet
     ./bootstrap
     STRIP=true CPPFLAGS="-DUSE_IPV6=1 -DW32_VEH" CFLAGS="$CFLAGS -g -O2" \
     ./configure --prefix=/ --docdir=/share/doc/gnunet \
     --with-libiconv-prefix=/mingw --with-libintl-prefix=/mingw \
     --with-libcurl=/mingw --with-extractor=/mingw --with-sqlite=/mingw \
     --with-microhttpd=/mingw --with-plibc=/mingw --enable-benchmarks \
     --enable-expensivetests --enable-experimental --with-qrencode=/mingw \
     --enable-silent-rules --enable-experimental 2>&1 | tee -a ./configure.log

   The parameters above will configure for a reasonable GNUnet
installation to the your msys-root directory.  Depending on which
features your would like to build or you may need to specify additional
dependencies.  Sbuild installed most libs into the /mingw subdirectory,
so remember to prefix library locations with this path.

   Like on a unixoid system, you might want to use your home directory
as prefix for your own GNUnet installation for development, without
tainting the buildenvironment.  Just change the "prefix" parameter to
point towards ~/ in this case.

   Now it’s time to compile GNUnet as usual.  Though this will take some
time, so you may fetch yourself a coffee or some Mate now...

     make ; make install


File: gnunet.info,  Node: Adjusting Windows for running and testing GNUnet,  Next: Building the GNUnet Installer,  Prev: GNUnet Installation,  Up: Build Instructions for Microsoft Windows Platforms

3.6.5 Adjusting Windows for running and testing GNUnet
------------------------------------------------------

Assuming the build succeeded and you *added the bin directory of your
GNUnet to PATH*, you can now use your gnunet-installation as usual.
Remember that UAC or the windows firewall may popup initially, blocking
further execution of gnunet until you acknowledge them.

   You will also have to take the usual steps to get peer-to-peer (p2p)
software running properly (port forwarding, ...), and GNUnet will
require administrative permissions as it may even install a
device-driver (in case you are using gnunet-vpn and/or gnunet-exit).


File: gnunet.info,  Node: Building the GNUnet Installer,  Next: Using GNUnet with Netbeans on Windows,  Prev: Adjusting Windows for running and testing GNUnet,  Up: Build Instructions for Microsoft Windows Platforms

3.6.6 Building the GNUnet Installer
-----------------------------------

The GNUnet installer is made with NSIS (http://nsis.sourceforge.net/).
The installer script is located in ‘contrib\win’ in the GNUnet source
tree.


File: gnunet.info,  Node: Using GNUnet with Netbeans on Windows,  Prev: Building the GNUnet Installer,  Up: Build Instructions for Microsoft Windows Platforms

3.6.7 Using GNUnet with Netbeans on Windows
-------------------------------------------

TODO


File: gnunet.info,  Node: Build instructions for Debian 7.5,  Next: Installing GNUnet from Git on Ubuntu 14.4,  Prev: Build Instructions for Microsoft Windows Platforms,  Up: GNUnet Installation Handbook

3.7 Build instructions for Debian 7.5
=====================================

These are the installation instructions for Debian 7.5.  They were
tested using a minimal, fresh Debian 7.5 AMD64 installation without
non-free software (no contrib or non-free).  By "minimal", we mean that
during installation, we did not select any desktop environment, servers
or system utilities during the "tasksel" step.  Note that the packages
and the dependencies that we will install during this chapter take about
1.5 GB of disk space.  Combined with GNUnet and space for objects during
compilation, you should not even attempt this unless you have about 2.5
GB free after the minimal Debian installation.  Using these instructions
to build a VM image is likely to require a minimum of 4-5 GB for the VM
(as you will likely also want a desktop manager).

   GNUnet’s security model assumes that your ‘/home’ directory is
encrypted.  Thus, if possible, you should encrypt your home partition
(or per-user home directory).

   Naturally, the exact details of the starting state for your
installation should not matter much.  For example, if you selected any
of those installation groups you might simply already have some of the
necessary packages installed.  We did this for testing, as this way we
are less likely to forget to mention a required package.  Note that we
will not install a desktop environment, but of course you will need to
install one to use GNUnet’s graphical user interfaces.  Thus, it is
suggested that you simply install the desktop environment of your choice
before beginning with the instructions.

* Menu:

* Update::
* Stable? Hah!::
* Update again::
* Installing packages::
* Installing dependencies from source::
* Installing GNUnet from source::
* But wait there is more!::


File: gnunet.info,  Node: Update,  Next: Stable? Hah!,  Up: Build instructions for Debian 7.5

3.7.1 Update
------------

After any installation, you should begin by running

     # apt-get update ; apt-get upgrade

   to ensure that all of your packages are up-to-date.  Note that the
"#" is used to indicate that you need to type in this command as "root"
(or prefix with "sudo"), whereas "$" is used to indicate typing in a
command as a normal user.


File: gnunet.info,  Node: Stable? Hah!,  Next: Update again,  Prev: Update,  Up: Build instructions for Debian 7.5

3.7.2 Stable? Hah!
------------------

Yes, we said we start with a Debian 7.5 "stable" system.  However, to
reduce the amount of compilation by hand, we will begin by allowing the
installation of packages from the testing and unstable distributions as
well.  We will stick to "stable" packages where possible, but some
packages will be taken from the other distributions.  Start by modifying
‘/etc/apt/sources.list’ to contain the following (possibly adjusted to
point to your mirror of choice):

     # These were there before:
     deb http://ftp.de.debian.org/debian/ wheezy main
     deb-src http://ftp.de.debian.org/debian/ wheezy main
     deb http://security.debian.org/ wheezy/updates main
     deb-src http://security.debian.org/ wheezy/updates main
     deb http://ftp.de.debian.org/debian/ wheezy-updates main
     deb-src http://ftp.de.debian.org/debian/ wheezy-updates main

     # Add these lines (feel free to adjust the mirror):
     deb http://ftp.de.debian.org/debian/ testing main
     deb http://ftp.de.debian.org/debian/ unstable main

   The next step is to create/edit your ‘/etc/apt/preferences’ file to
look like this:

     Package: *
     Pin: release a=stable,n=wheezy
     Pin-Priority: 700

     Package: *
     Pin: release o=Debian,a=testing
     Pin-Priority: 650

     Package: *
     Pin: release o=Debian,a=unstable
     Pin-Priority: 600

   You can read more about Apt Preferences here and here.  Note that
other pinnings are likely to also work for GNUnet, the key thing is that
you need some packages from unstable (as shown below).  However, as
unstable is unlikely to be comprehensive (missing packages) or might be
problematic (crashing packages), you probably want others from stable
and/or testing.


File: gnunet.info,  Node: Update again,  Next: Installing packages,  Prev: Stable? Hah!,  Up: Build instructions for Debian 7.5

3.7.3 Update again
------------------

Now, run again 

     # apt-get update # apt-get upgrade 

   to ensure that all your new distribution indices are downloaded, and
that your pinning is correct: the upgrade step should cause no changes
at all.


File: gnunet.info,  Node: Installing packages,  Next: Installing dependencies from source,  Prev: Update again,  Up: Build instructions for Debian 7.5

3.7.4 Installing packages
-------------------------

We begin by installing a few Debian packages from stable: 

     # apt-get install gcc make python-zbar libltdl-dev libsqlite3-dev \
       libunistring-dev libopus-dev libpulse-dev openssl libglpk-dev \
       texlive libidn11-dev libmysqlclient-dev libpq-dev libarchive-dev \
       libbz2-dev libexiv2-dev libflac-dev libgif-dev libglib2.0-dev \
       libgtk-3-dev libmagic-dev libjpeg8-dev libmpeg2-4-dev libmp4v2-dev \
       librpm-dev libsmf-dev libtidy-dev libtiff5-dev libvorbis-dev \
       libogg-dev zlib1g-dev g++ gettext libgsf-1-dev libunbound-dev \
       libqrencode-dev libgladeui-dev nasm texlive-latex-extra \
       libunique-3.0-dev gawk miniupnpc libfuse-dev libbluetooth-dev

   After that, we install a few more packages from unstable: 

     # apt-get install -t unstable nettle-dev libgstreamer1.0-dev \
       gstreamer1.0-plugins-base gstreamer1.0-plugins-good \
       libgstreamer-plugins-base1.0-dev


File: gnunet.info,  Node: Installing dependencies from source,  Next: Installing GNUnet from source,  Prev: Installing packages,  Up: Build instructions for Debian 7.5

3.7.5 Installing dependencies from source
-----------------------------------------

Next, we need to install a few dependencies from source.  You might want
to do this as a "normal" user and only run the ‘make install’ steps as
root (hence the ‘sudo’ in the commands below).  Also, you do this from
any directory.  We begin by downloading all dependencies, then
extracting the sources, and finally compiling and installing the
libraries.

   For these steps, follow the instructions given in the installation
from source instruction in this order:

   • *note generic source installation - libav::
   • *note generic source installation - libextractor::
   • *note generic source installation - libgpg-error::
   • *note generic source installation - libgcrypt::
   • *note generic source installation - gnutls::
   • *note generic source installation - libmicrohttpd::
   • *note generic source installation - libgnurl::


File: gnunet.info,  Node: Installing GNUnet from source,  Next: But wait there is more!,  Prev: Installing dependencies from source,  Up: Build instructions for Debian 7.5

3.7.6 Installing GNUnet from source
-----------------------------------

For this, simply follow the generic installation instructions from here.


File: gnunet.info,  Node: But wait there is more!,  Prev: Installing GNUnet from source,  Up: Build instructions for Debian 7.5

3.7.7 But wait there is more!
-----------------------------

So far, we installed all of the packages and dependencies required to
ensure that all of GNUnet would be built.  However, while for example
the plugins to interact with the MySQL or Postgres databases have been
created, we did not actually install or configure those databases.
Thus, you will need to install and configure those databases or stick
with the default Sqlite database.  Sqlite is usually fine for most
applications, but MySQL can offer better performance and Postgres better
resillience.


File: gnunet.info,  Node: Installing GNUnet from Git on Ubuntu 14.4,  Next: Build instructions for Debian 8,  Prev: Build instructions for Debian 7.5,  Up: GNUnet Installation Handbook

3.8 Installing GNUnet from Git on Ubuntu 14.4
=============================================

*Install the required build tools:*

     $ sudo apt-get install git automake autopoint autoconf

   *Install the required dependencies*

     $ sudo apt-get install libltdl-dev libgpg-error-dev libidn11-dev \
      libunistring-dev libglpk-dev libbluetooth-dev libextractor-dev \
      libmicrohttpd-dev libgnutls28-dev

   *Choose one or more database backends*

   • SQLite3:

          $ sudo apt-get install libsqlite3-dev

   • MySQL:

          $ sudo apt-get install libmysqlclient-dev

   • PostgreSQL:

          $ sudo apt-get install libpq-dev postgresql

   *Install the optional dependencies for gnunet-conversation:*

     $ sudo apt-get install gstreamer1.0 libpulse-dev libopus-dev

   *Install the libgrypt 1.6.1:*

   • For Ubuntu 14.04:

          $ sudo apt-get install libgcrypt20-dev

   • For Ubuntu older 14.04:

          $ wget ftp://ftp.gnupg.org/gcrypt/libgcrypt/libgcrypt-1.6.1.tar.bz2
          $ tar xf libgcrypt-1.6.1.tar.bz2
          $ cd libgcrypt-1.6.1
          $ ./configure
          $ sudo make install
          $ cd ..

   *Install libgnurl*

     $ wget https://gnunet.org/sites/default/files/gnurl-7.35.0.tar.bz2
     $ tar xf gnurl-7.35.0.tar.bz2
     $ cd gnurl-7.35.0
     $ ./configure --enable-ipv6 --with-gnutls --without-libssh2 \
      --without-libmetalink --without-winidn --without-librtmp \
      --without-nghttp2 --without-nss --without-cyassl --without-polarssl \
      --without-ssl --without-winssl --without-darwinssl --disable-sspi \
      --disable-ntlm-wb --disable-ldap --disable-rtsp --disable-dict \
      --disable-telnet --disable-tftp --disable-pop3 --disable-imap \
      --disable-smtp --disable-gopher --disable-file --disable-ftp
     $ sudo make install
     $ cd ..

   *Install GNUnet*

     $ git clone https://gnunet.org/git/gnunet/
     $ cd gnunet/
     $ ./bootstrap

   If you want to:

   • Install to a different directory:

          --prefix=PREFIX

   • Have sudo permission, but do not want to compile as root:

          --with-sudo

   • Want debug message enabled:

          --enable-logging=verbose

     $ ./configure [ --with-sudo | --prefix=PREFIX | --enable-logging=verbose]
     $ make; sudo make install

   After installing it, you need to create an empty configuration file:

     touch ~/.config/gnunet.conf

   And finally you can start GNUnet with

     $ gnunet-arm -s


File: gnunet.info,  Node: Build instructions for Debian 8,  Next: Build instructions for macOS,  Prev: Installing GNUnet from Git on Ubuntu 14.4,  Up: GNUnet Installation Handbook

3.9 Build instructions for Debian 8
===================================

These are the installation instructions for Debian 8.  They were tested
sing a fresh Debian 8 AMD64 installation without non-free software (no
contrib or non-free).  During installation, I only selected "lxde" for
the desktop environment.  Note that the packages and the dependencies
that we will install during this chapter take about 1.5 GB of disk
space.  Combined with GNUnet and space for objects during compilation,
you should not even attempt this unless you have about 2.5 GB free after
the Debian installation.  Using these instructions to build a VM image
is likely to require a minimum of 4-5 GB for the VM (as you will likely
also want a desktop manager).

   GNUnet’s security model assumes that your ‘/home’ directory is
encrypted.  Thus, if possible, you should encrypt your entire disk, or
at least just your home partition (or per-user home directory).

   Naturally, the exact details of the starting state for your
installation should not matter much.  For example, if you selected any
of those installation groups you might simply already have some of the
necessary packages installed.  Thus, it is suggested that you simply
install the desktop environment of your choice before beginning with the
instructions.

* Menu:

* Update Debian::
* Installing Debian Packages::
* Installing Dependencies from Source2::
* Installing GNUnet from Source2::
* But wait (again) there is more!::


File: gnunet.info,  Node: Update Debian,  Next: Installing Debian Packages,  Up: Build instructions for Debian 8

3.9.1 Update Debian
-------------------

After any installation, you should begin by running

     # apt-get update
     # apt-get upgrade

   to ensure that all of your packages are up-to-date.  Note that the
"#" is used to indicate that you need to type in this command as "root"
(or prefix with "sudo"), whereas "$" is used to indicate typing in a
command as a normal user.


File: gnunet.info,  Node: Installing Debian Packages,  Next: Installing Dependencies from Source2,  Prev: Update Debian,  Up: Build instructions for Debian 8

3.9.2 Installing Debian Packages
--------------------------------

We begin by installing a few Debian packages from stable:

     # apt-get install gcc make python-zbar libltdl-dev libsqlite3-dev \
     libunistring-dev libopus-dev libpulse-dev openssl libglpk-dev texlive \
     libidn11-dev libmysqlclient-dev libpq-dev libarchive-dev libbz2-dev \
     libflac-dev libgif-dev libglib2.0-dev libgtk-3-dev libmpeg2-4-dev \
     libtidy-dev libvorbis-dev libogg-dev zlib1g-dev g++ gettext \
     libgsf-1-dev libunbound-dev libqrencode-dev libgladeui-dev nasm \
     texlive-latex-extra libunique-3.0-dev gawk miniupnpc libfuse-dev \
     libbluetooth-dev gstreamer1.0-plugins-base gstreamer1.0-plugins-good \
     libgstreamer-plugins-base1.0-dev nettle-dev libextractor-dev \
     libgcrypt20-dev libmicrohttpd-dev


File: gnunet.info,  Node: Installing Dependencies from Source2,  Next: Installing GNUnet from Source2,  Prev: Installing Debian Packages,  Up: Build instructions for Debian 8

3.9.3 Installing Dependencies from Source2
------------------------------------------

Yes, we said we start with a Debian 8 "stable" system, but because
Debian linked GnuTLS without support for DANE, we need to compile a few
things, in addition to GNUnet, still by hand.  Yes, you can run GNUnet
using the respective Debian packages, but then you will not get DANE
support.

   Next, we need to install a few dependencies from source.  You might
want to do this as a "normal" user and only run the ‘make install’ steps
as root (hence the ‘sudo’ in the commands below).  Also, you do this
from any directory.  We begin by downloading all dependencies, then
extracting the sources, and finally compiling and installing the
libraries:

     $ wget ftp://ftp.gnutls.org/gcrypt/gnutls/v3.3/gnutls-3.3.12.tar.xz
     $ tar xvf gnutls-3.3.12.tar.xz
     $ cd gnutls-3.3.12 ; ./configure ; make ; sudo make install ; cd ..

   For the installation and compilation of libgnurl/gnURL refer to the
generic installation section, *Note generic source installation -
libgnurl::.


File: gnunet.info,  Node: Installing GNUnet from Source2,  Next: But wait (again) there is more!,  Prev: Installing Dependencies from Source2,  Up: Build instructions for Debian 8

3.9.4 Installing GNUnet from Source2
------------------------------------

For this, simply follow the generic installation instructions from here.


File: gnunet.info,  Node: But wait (again) there is more!,  Prev: Installing GNUnet from Source2,  Up: Build instructions for Debian 8

3.9.5 But wait (again) there is more!
-------------------------------------

So far, we installed all of the packages and dependencies required to
ensure that all of GNUnet would be built.  However, while for example
the plugins to interact with the MySQL or Postgres databases have been
created, we did not actually install or configure those databases.
Thus, you will need to install and configure those databases or stick
with the default Sqlite database.  Sqlite is usually fine for most
applications, but MySQL can offer better performance and Postgres better
resillience.


File: gnunet.info,  Node: Build instructions for macOS,  Next: Outdated build instructions for previous revisions,  Prev: Build instructions for Debian 8,  Up: GNUnet Installation Handbook

3.10 Build instructions for macOS
=================================

These are the installation guidelines for macOS. They were tested on
macOS High Sierra.

* Menu:

* Installing dependencies::
* Compile from Source::


File: gnunet.info,  Node: Installing dependencies,  Next: Compile from Source,  Up: Build instructions for macOS

3.10.1 Installing dependencies
------------------------------

First, install XCode in the newest version.  See
https://developer.apple.com/xcode/.

   Install Homebrew (https://brew.sh) and then install the dependencies
listed above.  If a dependency does not exists in brew, you need to
compile it from source.

     # brew install <dependency>


File: gnunet.info,  Node: Compile from Source,  Prev: Installing dependencies,  Up: Build instructions for macOS

3.10.2 Compile from Source
--------------------------

Before you start building GNUnet, you need to setup your environment.
This means that you have to make sure the proper tools are used in the
build process.  For example, after installing texinfo you need to make
sure the new texinfo is actually used:

     # echo 'export PATH="/usr/local/opt/texinfo/bin:$PATH"' >> ~/.bash_profile

   Note: brew tells you the appropriate command when executing

     # brew info texinfo

   This may also be necessary for the gettext package.

   Before you start compiling, you need to make sure gcc is used and not
the clang compile of your macOS system.  On my system, gcc was actually
“gcc-7” and gcc pointed to the clang compiler.

     # export CC=gcc-7

   After this the standard compile instructions apply.


File: gnunet.info,  Node: Outdated build instructions for previous revisions,  Next: The graphical configuration interface,  Prev: Build instructions for macOS,  Up: GNUnet Installation Handbook

3.11 Outdated build instructions for previous revisions
=======================================================

This chapter contains a collection of outdated, older installation
guides.  They are mostly intended to serve as a starting point for
writing up-to-date instructions and should not be expected to work for
GNUnet 0.10.x.  A set of older installation instructions can also be
found in the file ‘doc/outdated-and-old-installation-instructions.txt’
in the source tree of GNUnet.

   This file covers old instructions which no longer receive security
updates or any kind of support.

* Menu:

* Installing GNUnet 0.10.1 on Ubuntu 14.04::
* Building GLPK for MinGW::
* GUI build instructions for Ubuntu 12.04 using Subversion::
* Instructions for Microsoft Windows Platforms (Old)::


File: gnunet.info,  Node: Installing GNUnet 0.10.1 on Ubuntu 14.04,  Next: Building GLPK for MinGW,  Up: Outdated build instructions for previous revisions

3.11.1 Installing GNUnet 0.10.1 on Ubuntu 14.04
-----------------------------------------------

Install the required dependencies:

     $ sudo apt-get install libltdl-dev libgpg-error-dev libidn11-dev \
      libunistring-dev libglpk-dev libbluetooth-dev libextractor-dev \
      libmicrohttpd-dev libgnutls28-dev

   Choose one or more database backends:

   • SQLite3

           $ sudo apt-get install libsqlite3-dev 

   • MySQL

          $ sudo apt-get install libmysqlclient-dev 

   • PostgreSQL

           $ sudo apt-get install libpq-dev postgresql 

   Install the optional dependencies for gnunet-conversation:

      $ sudo apt-get install gstreamer1.0 libpulse-dev libopus-dev

   Install libgcrypt 1.6:

   • For Ubuntu 14.04:

          $ sudo apt-get install libgcrypt20-dev

   • For Ubuntu older than 14.04:

          wget ftp://ftp.gnupg.org/gcrypt/libgcrypt/libgcrypt-1.6.1.tar.bz2
          $ tar xf libgcrypt-1.6.1.tar.bz2
          $ cd libgcrypt-1.6.1
          $ ./configure
          $ sudo make install
          $ cd ..

   Install libgnurl:

   *note generic source installation - libgnurl::.

   Install GNUnet:

     $ wget http://ftpmirror.gnu.org/gnunet/gnunet-0.10.1.tar.gz
     $ tar xf gnunet-0.10.1.tar.gz
     $ cd gnunet-0.10.1

   If you want to:

   • Install to a different directory:

          --prefix=PREFIX

   • Have sudo permission, but do not want to compile as root:

          --with-sudo

   • Want debug message enabled:

          --enable-logging=verbose

     $ ./configure [ --with-sudo | --prefix=PREFIX | --enable-logging=verbose]
     $ make; sudo make install

   After installing it, you need to create an empty configuration file:

     touch ~/.config/gnunet.conf

   And finally you can start GNUnet with

     $ gnunet-arm -s


File: gnunet.info,  Node: Building GLPK for MinGW,  Next: GUI build instructions for Ubuntu 12.04 using Subversion,  Prev: Installing GNUnet 0.10.1 on Ubuntu 14.04,  Up: Outdated build instructions for previous revisions

3.11.2 Building GLPK for MinGW
------------------------------

GNUnet now requires the GNU Linear Programming Kit (GLPK). Since there’s
is no package you can install with ‘mingw-get’ you have to compile it
from source:

   • Download the latest version from <http://ftp.gnu.org/gnu/glpk/>

   • Unzip the downloaded source tarball using your favourite unzipper
     application In the MSYS shell

   • change to the respective directory

   • Configure glpk for "i686-pc-mingw32":

          ./configure '--build=i686-pc-mingw32'

   • run

          make install check

   MinGW does not automatically detect the correct buildtype so you have
to specify it manually.


File: gnunet.info,  Node: GUI build instructions for Ubuntu 12.04 using Subversion,  Next: Instructions for Microsoft Windows Platforms (Old),  Prev: Building GLPK for MinGW,  Up: Outdated build instructions for previous revisions

3.11.3 GUI build instructions for Ubuntu 12.04 using Subversion
---------------------------------------------------------------

After installing GNUnet you can continue installing the GNUnet GUI
tools:

   First, install the required dependencies:

     $ sudo apt-get install libgladeui-dev libqrencode-dev

   Please ensure that the GNUnet shared libraries can be found by the
linker.  If you installed GNUnet libraries in a non standard path (say
GNUNET_PREFIX=/usr/local/lib/), you can

   • set the environmental variable permanently to:

          LD_LIBRARY_PATH=$GNUNET_PREFIX

   • or add ‘$GNUNET_PREFIX’ to ‘/etc/ld.so.conf’

   Now you can checkout and compile the GNUnet GUI tools:

     $ git clone https://gnunet.org/git/gnunet-gtk
     $ cd gnunet-gtk
     $ ./bootstrap
     $ ./configure --prefix=$GNUNET_PREFIX/.. --with-gnunet=$GNUNET_PREFIX/..
     $ make install


File: gnunet.info,  Node: Instructions for Microsoft Windows Platforms (Old),  Prev: GUI build instructions for Ubuntu 12.04 using Subversion,  Up: Outdated build instructions for previous revisions

3.11.4 Instructions for Microsoft Windows Platforms (Old)
---------------------------------------------------------

This document is a DEPRECATED installation guide for GNUnet on Windows.
It will not work for recent GNUnet versions, but maybe it will be of
some use if problems arise.

   The Windows build uses a UNIX emulator for Windows, MinGW
(http://www.mingw.org/), to build the executable modules.  These modules
run natively on Windows and do not require additional emulation software
besides the usual dependencies.

   GNUnet development is mostly done under GNU/Linux and especially git
checkouts may not build out of the box.  We regret any inconvenience,
and if you have problems, please report them.

* Menu:

* Hardware and OS requirements::
* Software installation::
* Building libextractor and GNUnet::
* Installer::
* Source::


File: gnunet.info,  Node: Hardware and OS requirements,  Next: Software installation,  Up: Instructions for Microsoft Windows Platforms (Old)

3.11.4.1 Hardware and OS requirements
.....................................

   • Pentium II or equivalent processor, ≥ 350 MHz

   • 128 MB RAM

   • 600 MB free disk space

   • Windows 2000 or Windows XP are recommended


File: gnunet.info,  Node: Software installation,  Next: Building libextractor and GNUnet,  Prev: Hardware and OS requirements,  Up: Instructions for Microsoft Windows Platforms (Old)

3.11.4.2 Software installation
..............................

   • *Compression software* 

     The software packages GNUnet depends on are usually compressed
     using UNIX tools like ‘tar’, ‘gzip’, ‘xzip’ and ‘bzip2’.  If you do
     not already have an utility that is able to extract such archives,
     get 7-Zip (http://www.7-zip.org/).

   • *UNIX environment* 

     The MinGW project provides the compiler toolchain that is used to
     build GNUnet.  Get the following packages from the MinGW
     (http://sourceforge.net/projects/mingw/files/) project:

        • GCC core
        • GCC g++
        • MSYS
        • MSYS Developer Tool Kit (msysDTK)
        • MSYS Developer Tool Kit - msys-autoconf (bin)
        • MSYS Developer Tool Kit - msys-automake (bin)
        • MinGW Runtime
        • MinGW Utilities
        • Windows API
        • Binutils
        • make
        • pdcurses
        • GDB (snapshot)

        • Install MSYS (to c:\mingw, for example.) Do *not* use spaces
          in the pathname.  For example, avoid a location such as
          ‘c:\program files\mingw’.

        • Install MinGW runtime, utilities and GCC to a subdirectory (to
          ‘c:\mingw\mingw’, for example)

        • Install the Development Kit to the MSYS directory (‘c:\mingw’)

        • Create a batch file bash.bat in your MSYS directory with the
          files:

               bin\sh.exe --login

          This batch file opens a shell which is used to invoke the
          build processes.  MinGW’s standard shell (‘msys.bat’) is not
          suitable because it opens a separate console window.  On
          Vista, ‘bash.bat’ needs to be run as Administrator.

        • Start ‘bash.sh’ and rename ‘c:\mingw\mingw\lib\libstdc++.la’
          to avoid problems:

               mv /usr/mingw/lib/libstdc++.la /usr/mingw/lib/libstdc++.la.broken

        • Unpack the Windows API to the MinGW directory
          (‘c:\mingw\mingw\’) and remove the declaration of DATADIR from
          (‘c:\mingw\mingw\include\objidl.h’ (lines 55-58)

        • Unpack autoconf, automake to the MSYS directory (‘c:\mingw’)

        • Install all other packages to the MinGW directory
          (‘c:\mingw\mingw\’)

   • *GNU Libtool* GNU Libtool is required to use shared libraries.  Get
     the prebuilt package from here and unpack it to the MinGW directory
     (‘c:\mingw’)

   • *Pthreads* GNUnet uses the portable POSIX thread library for
     multi-threading:

        • Save libpthreadGC2.a
          (ftp://sources.redhat.com/pub/pthreads-win32/dll-latest/lib/x86/libpthreadGC2.a)
          (x86) or libpthreadGC2.a
          (ftp://sources.redhat.com/pub/pthreads-win32/dll-latest/lib/x64/libpthreadGC2.a)
          (x64) as libpthread.a into the ‘lib’ directory
          (‘c:\mingw\mingw\lib\libpthread.a’).

        • Save pthreadGC2.dll
          (ftp://sources.redhat.com/pub/pthreads-win32/dll-latest/lib/x86/pthreadGC2.dll)
          (x86) or libpthreadGC2.a
          (ftp://sources.redhat.com/pub/pthreads-win32/dll-latest/lib/x64/pthreadGC2.dll)
          (x64) into the MinGW ‘bin’ directory (‘c:\mingw\mingw\bin’).

        • Download all header files from include/
          (ftp://sources.redhat.com/pub/pthreads-win32/dll-latest/include/)
          to the ‘include’ directory (‘c:\mingw\mingw\include’).

   • *GNU MP* GNUnet uses the GNU Multiple Precision library for special
     cryptographic operations.  Get the GMP binary package from the
     MinGW repository (http://sourceforge.net/projects/mingwrep/) and
     unpack it to the MinGW directory (‘c:\mingw\mingw’)

   • *GNU Gettext* GNU gettext is used to provide national language
     support.  Get the prebuilt package from hereand unpack it to the
     MinGW directory (‘c:\mingw\mingw’)

   • *GNU iconv* GNU Libiconv is used for character encoding conversion.
     Get the prebuilt package from here and unpack it to the MinGW
     directory (‘c:\mingw\mingw’).

   • *SQLite* GNUnet uses the SQLite database to store data.  Get the
     prebuilt binary from here and unpack it to your MinGW directory.

   • *MySQL* As an alternative to SQLite, GNUnet also supports MySQL.

        • Get the binary installer from the MySQL project
          (http://dev.mysql.com/downloads/mysql/4.1.html#Windows)
          (version 4.1), install it and follow the instructions in
          ‘README.mysql’.

        • Create a temporary build directory (‘c:\mysql’)

        • Copy the directories ‘include\’ and ‘lib\’ from the MySQL
          directory to the new directory

        • Get the patches from Bug #8906
          (http://bugs.mysql.com/bug.php?id=8906&files=1) and Bug #8872
          (http://bugs.mysql.com/bug.php?id=8872&files=1) (the latter is
          only required for MySQL

               patch -p 0

        • Move ‘lib\opt\libmysql.dll’ to ‘lib\libmysql.dll’

        • Change to ‘lib\’ and create an import library:

               dlltool --input-def ../include/libmySQL.def \
               --dllname libmysql.dll \
               --output-lib libmysqlclient.a -k

        • Copy include\* to include\mysql\

        • Pass ‘--with-mysql=/c/mysql’ to ‘./configure’ and copy
          ‘libmysql.dll’ to your PATH or GNUnet’s ‘bin’ directory

   • *GTK+* ‘gnunet-fs-gtk’ and ‘libextractor’ depend on GTK. Get the
     the binary and developer packages of ‘atk’, ‘glib’, ‘gtk’, ‘iconv’,
     ‘gettext-runtime’, ‘pango’ from gtk.org
     (ftp://ftp.gtk.org/pub/gtk/v2.6/win32) and unpack them to the MinGW
     directory (‘c:\mingw\mingw’).  Get pkg-config
     (http://www.gtk.org/download/win32.php) and ‘libpng’ and unpack
     them to the MinGW directory (‘c:\mingw\mingw’).  Here is an
     all-in-one package for the gtk+dependencies
     (http://ftp.gnome.org/pub/gnome/binaries/win32/gtk+/2.24/gtk+-bundle_2.24.10-20120208_win32.zip)
     .  Do not overwrite any existing files!

   • *Glade* ‘gnunet-*-gtk’ and ‘gnunet-setup’ were created using this
     interface builder

        • Get the Glade and libglade (-bin and -devel) packages (without
          GTK!) from GladeWin32 (http://gladewin32.sourceforge.net/) and
          unpack them to the MinGW directory (‘c:\mingw\mingw’).

        • Get ‘libxml’ from here and unpack it to the MinGW directory
          (‘c:\mingw\mingw’).

   • *zLib* ‘libextractor’ requires ‘zLib’ to decompress some file
     formats.  GNUnet uses it to (de)compress meta-data.  Get zLib from
     here (Signature) and unpack it to the MinGW directory
     (‘c:\mingw\mingw’).

   • *Bzip2* ‘libextractor’ also requires ‘Bzip2’ to decompress some
     file formats.  Get the Bzip2 (binary and developer package) from
     GnuWin32 (http://gnuwin32.sourceforge.net/packages/bzip2.htm) and
     unpack it to the MinGW directory (‘c:\mingw\mingw’).

   • *Libgcrypt* ‘Libgcrypt’ provides the cryptographic functions used
     by GNUnet.  Get Libgcrypt from here
     (ftp://ftp.gnupg.org/gcrypt/libgcrypt/), compile and place it in
     the MinGW directory (‘c:\mingw\mingw’).  Currently libgcrypt ≥
     1.4.2 is required to compile GNUnet.

   • *PlibC* PlibC emulates Unix functions under Windows.  Get PlibC
     from here and unpack it to the MinGW directory (c:\mingw\mingw)

   • *OGG Vorbis* ‘OGG Vorbis’ is used to extract meta-data from ‘.ogg’
     files.  Get the packages libogg
     (http://www.gnunet.org/libextractor/download/win/libogg-1.1.4.zip)
     and libvorbis
     (http://www.gnunet.org/libextractor/download/win/libvorbis-1.2.3.zip)
     from the libextractor win32 build
     (http://ftp.gnu.org/gnu/libextractor/libextractor-w32-1.0.0.zip)
     and unpack them to the MinGW directory (c:\mingw\mingw).

   • *Exiv2* (lib)Exiv2 is used to extract meta-data from files with
     Exiv2 meta-data.  Download Exiv2
     (http://www.gnunet.org/libextractor/download/win/exiv2-0.18.2.zip)
     and unpack it to the MSYS directory (c:\mingw).


File: gnunet.info,  Node: Building libextractor and GNUnet,  Next: Installer,  Prev: Software installation,  Up: Instructions for Microsoft Windows Platforms (Old)

3.11.4.3 Building libextractor and GNUnet
.........................................

Before you compile ‘libextractor’ or ‘GNUnet’, be sure to set
‘PKG_CONFIG_PATH’:

     export PKG_CONFIG_PATH=/mingw/lib/pkgconfig

*Note GNUnet Installation Handbook::, for basic instructions on building
‘libextractor’ and ‘GNUnet’.  By default, all modules that are created
in this way contain debug information and are quite large.  To compile
release versions (small and fast) set the variable ‘CFLAGS’:

     export CFLAGS='-O2 -march=pentium -fomit-frame-pointer'
     ./configure --prefix=$HOME --with-extractor=$HOME


File: gnunet.info,  Node: Installer,  Next: Source,  Prev: Building libextractor and GNUnet,  Up: Instructions for Microsoft Windows Platforms (Old)

3.11.4.4 Installer
..................

The GNUnet installer is made with NSIS (http://nsis.sourceforge.net/).
The installer script is located in ‘contrib\win’ in the GNUnet source
tree.


File: gnunet.info,  Node: Source,  Prev: Installer,  Up: Instructions for Microsoft Windows Platforms (Old)

3.11.4.5 Source
...............

The sources of all dependencies are available here.


File: gnunet.info,  Node: The graphical configuration interface,  Next: How to start and stop a GNUnet peer,  Prev: Outdated build instructions for previous revisions,  Up: GNUnet Installation Handbook

3.12 The graphical configuration interface
==========================================

If you also would like to use ‘gnunet-gtk’ and ‘gnunet-setup’ (highly
recommended for beginners), do:

     wget -P /tmp \
     https://gnunet.org/install/packs/gnunet-0.9.4-gtk-0.9.4-`uname -m`.tgz
     sh ~/gnunet-update/bin/gnunet-update install /tmp/gnunet-*gtk*.tgz ~
     sudo ldconfig

   Now you can run ‘gnunet-setup’ for easy configuration of your GNUnet
peer.

* Menu:

* Configuring your peer::
* Configuring the Friend-to-Friend (F2F) mode::
* Configuring the hostlist to bootstrap::
* Configuration of the HOSTLIST proxy settings::
* Configuring your peer to provide a hostlist ::
* Configuring the datastore::
* Configuring the MySQL database::
* Reasons for using MySQL::
* Reasons for not using MySQL::
* Setup Instructions::
* Testing::
* Performance Tuning::
* Setup for running Testcases::
* Configuring the Postgres database::
* Reasons to use Postgres::
* Reasons not to use Postgres::
* Manual setup instructions::
* Testing the setup manually::
* Configuring the datacache::
* Configuring the file-sharing service::
* Configuring logging::
* Configuring the transport service and plugins::
* Configuring the wlan transport plugin::
* Configuring HTTP(S) reverse proxy functionality using Apache or nginx::
* Blacklisting peers::
* Configuration of the HTTP and HTTPS transport plugins::
* Configuring the GNU Name System::
* Configuring the GNUnet VPN::
* Bandwidth Configuration::
* Configuring NAT::
* Peer configuration for distributions::


File: gnunet.info,  Node: Configuring your peer,  Next: Configuring the Friend-to-Friend (F2F) mode,  Up: The graphical configuration interface

3.12.1 Configuring your peer
----------------------------

This chapter will describe the various configuration options in GNUnet.

   The easiest way to configure your peer is to use the ‘gnunet-setup’
tool.  ‘gnunet-setup’ is part of the ‘gnunet-gtk’ application.  You
might have to install it separately.

   Many of the specific sections from this chapter actually are linked
from within ‘gnunet-setup’ to help you while using the setup tool.

   While you can also configure your peer by editing the configuration
file by hand, this is not recommended for anyone except for developers
as it requires a more in-depth understanding of the configuration files
and internal dependencies of GNUnet.


File: gnunet.info,  Node: Configuring the Friend-to-Friend (F2F) mode,  Next: Configuring the hostlist to bootstrap,  Prev: Configuring your peer,  Up: The graphical configuration interface

3.12.2 Configuring the Friend-to-Friend (F2F) mode
--------------------------------------------------

GNUnet knows three basic modes of operation:
   • In standard "peer-to-peer" mode, your peer will connect to any
     peer.
   • In the pure "friend-to-friend" mode, your peer will ONLY connect to
     peers from a list of friends specified in the configuration.
   • Finally, in mixed mode, GNUnet will only connect to arbitrary peers
     if it has at least a specified number of connections to friends.

   When configuring any of the F2F ("friend-to-friend") modes, you first
need to create a file with the peer identities of your friends.  Ask
your friends to run

     $ gnunet-peerinfo -sq

The resulting output of this command needs to be added to your ‘friends’
file, which is simply a plain text file with one line per friend with
the output from the above command.

   You then specify the location of your ‘friends’ file in the ‘FRIENDS’
option of the "topology" section.

   Once you have created the ‘friends’ file, you can tell GNUnet to only
connect to your friends by setting the ‘FRIENDS-ONLY’ option (again in
the "topology" section) to YES.

   If you want to run in mixed-mode, set "FRIENDS-ONLY" to NO and
configure a minimum number of friends to have (before connecting to
arbitrary peers) under the "MINIMUM-FRIENDS" option.

   If you want to operate in normal P2P-only mode, simply set
‘MINIMUM-FRIENDS’ to zero and ‘FRIENDS_ONLY’ to NO. This is the default.


File: gnunet.info,  Node: Configuring the hostlist to bootstrap,  Next: Configuration of the HOSTLIST proxy settings,  Prev: Configuring the Friend-to-Friend (F2F) mode,  Up: The graphical configuration interface

3.12.3 Configuring the hostlist to bootstrap
--------------------------------------------

After installing the software you need to get connected to the GNUnet
network.  The configuration file included in your download is already
configured to connect you to the GNUnet network.  In this section the
relevant configuration settings are explained.

   To get an initial connection to the GNUnet network and to get to know
peers already connected to the network you can use the so called
"bootstrap servers".  These servers can give you a list of peers
connected to the network.  To use these bootstrap servers you have to
configure the hostlist daemon to activate bootstrapping.

   To activate bootstrapping, edit the ‘[hostlist]’-section in your
configuration file.  You have to set the argument ‘-b’ in the options
line:

     [hostlist]
     OPTIONS = -b

   Additionally you have to specify which server you want to use.  The
default bootstrapping server is "http://v10.gnunet.org/hostlist
(http://v10.gnunet.org/hostlist)".  [^] To set the server you have to
edit the line "SERVERS" in the hostlist section.  To use the default
server you should set the lines to

     SERVERS = http://v10.gnunet.org/hostlist [^]

To use bootstrapping your configuration file should include these lines:

     [hostlist]
     OPTIONS = -b
     SERVERS = http://v10.gnunet.org/hostlist [^]

Besides using bootstrap servers you can configure your GNUnet peer to
recieve hostlist advertisements.  Peers offering hostlists to other
peers can send advertisement messages to peers that connect to them.  If
you configure your peer to receive these messages, your peer can
download these lists and connect to the peers included.  These lists are
persistent, which means that they are saved to your hard disk regularly
and are loaded during startup.

   To activate hostlist learning you have to add the ‘-e’ switch to the
‘OPTIONS’ line in the hostlist section:

     [hostlist]
     OPTIONS = -b -e

Furthermore you can specify in which file the lists are saved.  To save
the lists in the file ‘hostlists.file’ just add the line:

     HOSTLISTFILE = hostlists.file

Best practice is to activate both bootstrapping and hostlist learning.
So your configuration file should include these lines:

     [hostlist]
     OPTIONS = -b -e
     HTTPPORT = 8080
     SERVERS = http://v10.gnunet.org/hostlist [^]
     HOSTLISTFILE = $SERVICEHOME/hostlists.file


File: gnunet.info,  Node: Configuration of the HOSTLIST proxy settings,  Next: Configuring your peer to provide a hostlist,  Prev: Configuring the hostlist to bootstrap,  Up: The graphical configuration interface

3.12.4 Configuration of the HOSTLIST proxy settings
---------------------------------------------------

The hostlist client can be configured to use a proxy to connect to the
hostlist server.  This functionality can be configured in the
configuration file directly or using the ‘gnunet-setup’ tool.

   The hostlist client supports the following proxy types at the moment:

   • HTTP and HTTP 1.0 only proxy
   • SOCKS 4/4a/5/5 with hostname

   In addition authentication at the proxy with username and password
can be configured.

   To configure proxy support for the hostlist client in the
‘gnunet-setup’ tool, select the "hostlist" tab and select the
appropriate proxy type.  The hostname or IP address (including port if
required) has to be entered in the "Proxy hostname" textbox.  If
required, enter username and password in the "Proxy username" and "Proxy
password" boxes.  Be aware that this information will be stored in the
configuration in plain text (TODO: Add explanation and generalize the
part in Chapter 3.6 about the encrypted home).

   To provide these options directly in the configuration, you can enter
the following settings in the ‘[hostlist]’ section of the configuration:

     # Type of proxy server,
     # Valid values: HTTP, HTTP_1_0, SOCKS4, SOCKS5, SOCKS4A, SOCKS5_HOSTNAME
     # Default: HTTP
     # PROXY_TYPE = HTTP

     # Hostname or IP of proxy server
     # PROXY =
     # User name for proxy server
     # PROXY_USERNAME =
     # User password for proxy server
     # PROXY_PASSWORD =


File: gnunet.info,  Node: Configuring your peer to provide a hostlist,  Next: Configuring the datastore,  Prev: Configuration of the HOSTLIST proxy settings,  Up: The graphical configuration interface

3.12.5 Configuring your peer to provide a hostlist
--------------------------------------------------

If you operate a peer permanently connected to GNUnet you can configure
your peer to act as a hostlist server, providing other peers the list of
peers known to him.

   Your server can act as a bootstrap server and peers needing to obtain
a list of peers can contact it to download this list.  To download this
hostlist the peer uses HTTP. For this reason you have to build your peer
with libgnurl (or libcurl) and microhttpd support.  How you build your
peer with these options can be found here: *Note Generic installation
instructions::.

   To configure your peer to act as a bootstrap server you have to add
the ‘-p’ option to ‘OPTIONS’ in the ‘[hostlist]’ section of your
configuration file.  Besides that you have to specify a port number for
the http server.  In conclusion you have to add the following lines:

     [hostlist]
     HTTPPORT = 12980
     OPTIONS = -p

If your peer acts as a bootstrap server other peers should know about
that.  You can advertise the hostlist your are providing to other peers.
Peers connecting to your peer will get a message containing an
advertisement for your hostlist and the URL where it can be downloaded.
If this peer is in learning mode, it will test the hostlist and, in the
case it can obtain the list successfully, it will save it for
bootstrapping.

   To activate hostlist advertisement on your peer, you have to set the
following lines in your configuration file:

     [hostlist]
     EXTERNAL_DNS_NAME = example.org
     HTTPPORT = 12981
     OPTIONS = -p -a

With this configuration your peer will a act as a bootstrap server and
advertise this hostlist to other peers connecting to it.  The URL used
to download the list will be ‘http://example.org:12981/
(http://example.org:12981/)’.

   Please notice:

   • The hostlist is not human readable, so you should not try to
     download it using your webbrowser.  Just point your GNUnet peer to
     the address!
   • Advertising without providing a hostlist does not make sense and
     will not work.


File: gnunet.info,  Node: Configuring the datastore,  Next: Configuring the MySQL database,  Prev: Configuring your peer to provide a hostlist,  Up: The graphical configuration interface

3.12.6 Configuring the datastore
--------------------------------

The datastore is what GNUnet uses for long-term storage of file-sharing
data.  Note that long-term does not mean ’forever’ since content does
have an expiration date, and of course storage space is finite (and
hence sometimes content may have to be discarded).

   Use the ‘QUOTA’ option to specify how many bytes of storage space you
are willing to dedicate to GNUnet.

   In addition to specifying the maximum space GNUnet is allowed to use
for the datastore, you need to specify which database GNUnet should use
to do so.  Currently, you have the choice between sqLite, MySQL and
Postgres.


File: gnunet.info,  Node: Configuring the MySQL database,  Next: Reasons for using MySQL,  Prev: Configuring the datastore,  Up: The graphical configuration interface

3.12.7 Configuring the MySQL database
-------------------------------------

This section describes how to setup the MySQL database for GNUnet.

   Note that the mysql plugin does NOT work with mysql before 4.1 since
we need prepared statements.  We are generally testing the code against
MySQL 5.1 at this point.


File: gnunet.info,  Node: Reasons for using MySQL,  Next: Reasons for not using MySQL,  Prev: Configuring the MySQL database,  Up: The graphical configuration interface

3.12.8 Reasons for using MySQL
------------------------------

   • On up-to-date hardware wher mysql can be used comfortably, this
     module will have better performance than the other database choices
     (according to our tests).

   • Its often possible to recover the mysql database from internal
     inconsistencies.  Some of the other databases do not support
     repair.


File: gnunet.info,  Node: Reasons for not using MySQL,  Next: Setup Instructions,  Prev: Reasons for using MySQL,  Up: The graphical configuration interface

3.12.9 Reasons for not using MySQL
----------------------------------

   • Memory usage (likely not an issue if you have more than 1 GB)
   • Complex manual setup


File: gnunet.info,  Node: Setup Instructions,  Next: Testing,  Prev: Reasons for not using MySQL,  Up: The graphical configuration interface

3.12.10 Setup Instructions
--------------------------

   • In ‘gnunet.conf’ set in section ‘DATASTORE’ the value for
     ‘DATABASE’ to ‘mysql’.

   • Access mysql as root:

          $ mysql -u root -p

     and issue the following commands, replacing $USER with the username
     that will be running ‘gnunet-arm’ (so typically "gnunet"):

          CREATE DATABASE gnunet;
          GRANT select,insert,update,delete,create,alter,drop,create \
          temporary tables ON gnunet.* TO $USER@localhost;
          SET PASSWORD FOR $USER@localhost=PASSWORD('$the_password_you_like');
          FLUSH PRIVILEGES;

   • In the $HOME directory of $USER, create a ‘.my.cnf’ file with the
     following lines

          [client]
          user=$USER
          password=$the_password_you_like

   Thats it.  Note that ‘.my.cnf’ file is a slight security risk unless
its on a safe partition.  The ‘$HOME/.my.cnf’ can of course be a
symbolic link.  Luckily $USER has only priviledges to mess up GNUnet’s
tables, which should be pretty harmless.


File: gnunet.info,  Node: Testing,  Next: Performance Tuning,  Prev: Setup Instructions,  Up: The graphical configuration interface

3.12.11 Testing
---------------

You should briefly try if the database connection works.  First, login
as $USER. Then use:

     $ mysql -u $USER
     mysql> use gnunet;

If you get the message

     Database changed

it probably works.

   If you get

     ERROR 2002: Can't connect to local MySQL server
     through socket '/tmp/mysql.sock' (2)

it may be resolvable by

     ln -s /var/run/mysqld/mysqld.sock /tmp/mysql.sock

so there may be some additional trouble depending on your mysql setup.


File: gnunet.info,  Node: Performance Tuning,  Next: Setup for running Testcases,  Prev: Testing,  Up: The graphical configuration interface

3.12.12 Performance Tuning
--------------------------

For GNUnet, you probably want to set the option

     innodb_flush_log_at_trx_commit = 0

for a rather dramatic boost in MySQL performance.  However, this reduces
the "safety" of your database as with this options you may loose
transactions during a power outage.  While this is totally harmless for
GNUnet, the option applies to all applications using MySQL. So you
should set it if (and only if) GNUnet is the only application on your
system using MySQL.


File: gnunet.info,  Node: Setup for running Testcases,  Next: Configuring the Postgres database,  Prev: Performance Tuning,  Up: The graphical configuration interface

3.12.13 Setup for running Testcases
-----------------------------------

If you want to run the testcases, you must create a second database
"gnunetcheck" with the same username and password.  This database will
then be used for testing (‘make check’).


File: gnunet.info,  Node: Configuring the Postgres database,  Next: Reasons to use Postgres,  Prev: Setup for running Testcases,  Up: The graphical configuration interface

3.12.14 Configuring the Postgres database
-----------------------------------------

This text describes how to setup the Postgres database for GNUnet.

   This Postgres plugin was developed for Postgres 8.3 but might work
for earlier versions as well.


File: gnunet.info,  Node: Reasons to use Postgres,  Next: Reasons not to use Postgres,  Prev: Configuring the Postgres database,  Up: The graphical configuration interface

3.12.15 Reasons to use Postgres
-------------------------------

   • Easier to setup than MySQL
   • Real database


File: gnunet.info,  Node: Reasons not to use Postgres,  Next: Manual setup instructions,  Prev: Reasons to use Postgres,  Up: The graphical configuration interface

3.12.16 Reasons not to use Postgres
-----------------------------------

   • Quite slow
   • Still some manual setup required


File: gnunet.info,  Node: Manual setup instructions,  Next: Testing the setup manually,  Prev: Reasons not to use Postgres,  Up: The graphical configuration interface

3.12.17 Manual setup instructions
---------------------------------

   • In ‘gnunet.conf’ set in section ‘DATASTORE’ the value for
     ‘DATABASE’ to ‘postgres’.
   • Access Postgres to create a user:

     with Postgres 8.x, use:

               # su - postgres
               $ createuser

          and enter the name of the user running GNUnet for the role
          interactively.  Then, when prompted, do not set it to
          superuser, allow the creation of databases, and do not allow
          the creation of new roles.

     with Postgres 9.x, use:

               # su - postgres
               $ createuser -d $GNUNET_USER

          where $GNUNET_USER is the name of the user running GNUnet.

   • As that user (so typically as user "gnunet"), create a database (or
     two):

          $ createdb gnunet
          # this way you can run "make check"
          $ createdb gnunetcheck

   Now you should be able to start ‘gnunet-arm’.


File: gnunet.info,  Node: Testing the setup manually,  Next: Configuring the datacache,  Prev: Manual setup instructions,  Up: The graphical configuration interface

3.12.18 Testing the setup manually
----------------------------------

You may want to try if the database connection works.  First, again
login as the user who will run ‘gnunet-arm’.  Then use:

     $ psql gnunet # or gnunetcheck
     gnunet=> \dt

If, after you have started ‘gnunet-arm’ at least once, you get a ‘gn090’
table here, it probably works.


File: gnunet.info,  Node: Configuring the datacache,  Next: Configuring the file-sharing service,  Prev: Testing the setup manually,  Up: The graphical configuration interface

3.12.19 Configuring the datacache
---------------------------------

The datacache is what GNUnet uses for storing temporary data.  This data
is expected to be wiped completely each time GNUnet is restarted (or the
system is rebooted).

   You need to specify how many bytes GNUnet is allowed to use for the
datacache using the ‘QUOTA’ option in the section ‘[dhtcache]’.
Furthermore, you need to specify which database backend should be used
to store the data.  Currently, you have the choice between sqLite, MySQL
and Postgres.


File: gnunet.info,  Node: Configuring the file-sharing service,  Next: Configuring logging,  Prev: Configuring the datacache,  Up: The graphical configuration interface

3.12.20 Configuring the file-sharing service
--------------------------------------------

In order to use GNUnet for file-sharing, you first need to make sure
that the file-sharing service is loaded.  This is done by setting the
‘AUTOSTART’ option in section ‘[fs]’ to "YES". Alternatively, you can
run

     $ gnunet-arm -i fs

to start the file-sharing service by hand.

   Except for configuring the database and the datacache the only
important option for file-sharing is content migration.

   Content migration allows your peer to cache content from other peers
as well as send out content stored on your system without explicit
requests.  This content replication has positive and negative impacts on
both system performance and privacy.

   FIXME: discuss the trade-offs.  Here is some older text about it...

   Setting this option to YES allows gnunetd to migrate data to the
local machine.  Setting this option to YES is highly recommended for
efficiency.  Its also the default.  If you set this value to YES, GNUnet
will store content on your machine that you cannot decrypt.  While this
may protect you from liability if the judge is sane, it may not (IANAL).
If you put illegal content on your machine yourself, setting this option
to YES will probably increase your chances to get away with it since you
can plausibly deny that you inserted the content.  Note that in either
case, your anonymity would have to be broken first (which may be
possible depending on the size of the GNUnet network and the strength of
the adversary).


File: gnunet.info,  Node: Configuring logging,  Next: Configuring the transport service and plugins,  Prev: Configuring the file-sharing service,  Up: The graphical configuration interface

3.12.21 Configuring logging
---------------------------

Logging in GNUnet 0.9.0 is controlled via the "-L" and "-l" options.
Using ‘-L’, a log level can be specified.  With log level ‘ERROR’ only
serious errors are logged.  The default log level is ‘WARNING’ which
causes anything of concern to be logged.  Log level ‘INFO’ can be used
to log anything that might be interesting information whereas ‘DEBUG’
can be used by developers to log debugging messages (but you need to run
‘./configure’ with ‘--enable-logging=verbose’ to get them compiled).
The ‘-l’ option is used to specify the log file.

   Since most GNUnet services are managed by ‘gnunet-arm’, using the
‘-l’ or ‘-L’ options directly is not possible.  Instead, they can be
specified using the ‘OPTIONS’ configuration value in the respective
section for the respective service.  In order to enable logging globally
without editing the ‘OPTIONS’ values for each service, ‘gnunet-arm’
supports a ‘GLOBAL_POSTFIX’ option.  The value specified here is given
as an extra option to all services for which the configuration does
contain a service-specific ‘OPTIONS’ field.

   ‘GLOBAL_POSTFIX’ can contain the special sequence "{}" which is
replaced by the name of the service that is being started.  Furthermore,
‘GLOBAL_POSTFIX’ is special in that sequences starting with "$" anywhere
in the string are expanded (according to options in ‘PATHS’); this
expansion otherwise is only happening for filenames and then the "$"
must be the first character in the option.  Both of these restrictions
do not apply to ‘GLOBAL_POSTFIX’.  Note that specifying ‘%’ anywhere in
the ‘GLOBAL_POSTFIX’ disables both of these features.

   In summary, in order to get all services to log at level ‘INFO’ to
log-files called ‘SERVICENAME-logs’, the following global prefix should
be used:

     GLOBAL_POSTFIX = -l $SERVICEHOME/{}-logs -L INFO


File: gnunet.info,  Node: Configuring the transport service and plugins,  Next: Configuring the wlan transport plugin,  Prev: Configuring logging,  Up: The graphical configuration interface

3.12.22 Configuring the transport service and plugins
-----------------------------------------------------

The transport service in GNUnet is responsible to maintain basic
connectivity to other peers.  Besides initiating and keeping connections
alive it is also responsible for address validation.

   The GNUnet transport supports more than one transport protocol.
These protocols are configured together with the transport service.

   The configuration section for the transport service itself is quite
similar to all the other services

     AUTOSTART = YES
     @UNIXONLY@ PORT = 2091
     HOSTNAME = localhost
     HOME = $SERVICEHOME
     CONFIG = $DEFAULTCONFIG
     BINARY = gnunet-service-transport
     #PREFIX = valgrind
     NEIGHBOUR_LIMIT = 50
     ACCEPT_FROM = 127.0.0.1;
     ACCEPT_FROM6 = ::1;
     PLUGINS = tcp udp
     UNIXPATH = /tmp/gnunet-service-transport.sock

   Different are the settings for the plugins to load ‘PLUGINS’.  The
first setting specifies which transport plugins to load.

   • transport-unix A plugin for local only communication with UNIX
     domain sockets.  Used for testing and available on unix systems
     only.  Just set the port

          [transport-unix]
          PORT = 22086
          TESTING_IGNORE_KEYS = ACCEPT_FROM;

   • transport-tcp A plugin for communication with TCP. Set port to 0
     for client mode with outbound only connections

          [transport-tcp]
          # Use 0 to ONLY advertise as a peer behind NAT (no port binding)
          PORT = 2086
          ADVERTISED_PORT = 2086
          TESTING_IGNORE_KEYS = ACCEPT_FROM;
          # Maximum number of open TCP connections allowed
          MAX_CONNECTIONS = 128

   • transport-udp A plugin for communication with UDP. Supports peer
     discovery using broadcasts.

          [transport-udp]
          PORT = 2086
          BROADCAST = YES
          BROADCAST_INTERVAL = 30 s
          MAX_BPS = 1000000
          TESTING_IGNORE_KEYS = ACCEPT_FROM;

   • transport-http HTTP and HTTPS support is split in two part: a
     client plugin initiating outbound connections and a server part
     accepting connections from the client.  The client plugin just
     takes the maximum number of connections as an argument.

          [transport-http_client]
          MAX_CONNECTIONS = 128
          TESTING_IGNORE_KEYS = ACCEPT_FROM;

          [transport-https_client]
          MAX_CONNECTIONS = 128
          TESTING_IGNORE_KEYS = ACCEPT_FROM;

     The server has a port configured and the maximum nunber of
     connections.  The HTTPS part has two files with the certificate key
     and the certificate file.

     The server plugin supports reverse proxies, so a external hostname
     can be set using the ‘EXTERNAL_HOSTNAME’ setting.  The webserver
     under this address should forward the request to the peer and the
     configure port.

          [transport-http_server]
          EXTERNAL_HOSTNAME = fulcrum.net.in.tum.de/gnunet
          PORT = 1080
          MAX_CONNECTIONS = 128
          TESTING_IGNORE_KEYS = ACCEPT_FROM;

          [transport-https_server]
          PORT = 4433
          CRYPTO_INIT = NORMAL
          KEY_FILE = https.key
          CERT_FILE = https.cert
          MAX_CONNECTIONS = 128
          TESTING_IGNORE_KEYS = ACCEPT_FROM;

   • transport-wlan

     The next section describes how to setup the WLAN plugin, so here
     only the settings.  Just specify the interface to use:

          [transport-wlan]
          # Name of the interface in monitor mode (typically monX)
          INTERFACE = mon0
          # Real hardware, no testing
          TESTMODE = 0
          TESTING_IGNORE_KEYS = ACCEPT_FROM;


File: gnunet.info,  Node: Configuring the wlan transport plugin,  Next: Configuring HTTP(S) reverse proxy functionality using Apache or nginx,  Prev: Configuring the transport service and plugins,  Up: The graphical configuration interface

3.12.23 Configuring the wlan transport plugin
---------------------------------------------

The wlan transport plugin enables GNUnet to send and to receive data on
a wlan interface.  It has not to be connected to a wlan network as long
as sender and receiver are on the same channel.  This enables you to get
connection to GNUnet where no internet access is possible, for example
during catastrophes or when censorship cuts you off from the internet.

* Menu:

* Requirements for the WLAN plugin::
* Configuration::
* Before starting GNUnet::
* Limitations and known bugs::


File: gnunet.info,  Node: Requirements for the WLAN plugin,  Next: Configuration,  Up: Configuring the wlan transport plugin

3.12.23.1 Requirements for the WLAN plugin
..........................................

   • wlan network card with monitor support and packet injection (see
     aircrack-ng.org (http://www.aircrack-ng.org/))

   • Linux kernel with mac80211 stack, introduced in 2.6.22, tested with
     2.6.35 and 2.6.38

   • Wlantools to create the a monitor interface, tested with airmon-ng
     of the aircrack-ng package


File: gnunet.info,  Node: Configuration,  Next: Before starting GNUnet,  Prev: Requirements for the WLAN plugin,  Up: Configuring the wlan transport plugin

3.12.23.2 Configuration
.......................

There are the following options for the wlan plugin (they should be like
this in your default config file, you only need to adjust them if the
values are incorrect for your system)

     # section for the wlan transport plugin
     [transport-wlan]
     # interface to use, more information in the
     # "Before starting GNUnet" section of the handbook.
     INTERFACE = mon0
     # testmode for developers:
     # 0 use wlan interface,
     #1 or 2 use loopback driver for tests 1 = server, 2 = client
     TESTMODE = 0


File: gnunet.info,  Node: Before starting GNUnet,  Next: Limitations and known bugs,  Prev: Configuration,  Up: Configuring the wlan transport plugin

3.12.23.3 Before starting GNUnet
................................

Before starting GNUnet, you have to make sure that your wlan interface
is in monitor mode.  One way to put the wlan interface into monitor mode
(if your interface name is wlan0) is by executing:

     sudo airmon-ng start wlan0

Here is an example what the result should look like:

     Interface Chipset Driver
     wlan0 Intel 4965 a/b/g/n iwl4965 - [phy0]
     (monitor mode enabled on mon0)

The monitor interface is mon0 is the one that you have to put into the
configuration file.


File: gnunet.info,  Node: Limitations and known bugs,  Prev: Before starting GNUnet,  Up: Configuring the wlan transport plugin

3.12.23.4 Limitations and known bugs
....................................

Wlan speed is at the maximum of 1 Mbit/s because support for choosing
the wlan speed with packet injection was removed in newer kernels.
Please pester the kernel developers about fixing this.

   The interface channel depends on the wlan network that the card is
connected to.  If no connection has been made since the start of the
computer, it is usually the first channel of the card.  Peers will only
find each other and communicate if they are on the same channel.
Channels must be set manually, i.e.  using:

     iwconfig wlan0 channel 1


File: gnunet.info,  Node: Configuring HTTP(S) reverse proxy functionality using Apache or nginx,  Next: Blacklisting peers,  Prev: Configuring the wlan transport plugin,  Up: The graphical configuration interface

3.12.24 Configuring HTTP(S) reverse proxy functionality using Apache or nginx
-----------------------------------------------------------------------------

The HTTP plugin supports data transfer using reverse proxies.  A reverse
proxy forwards the HTTP request he receives with a certain URL to
another webserver, here a GNUnet peer.

   So if you have a running Apache or nginx webserver you can configure
it to be a GNUnet reverse proxy.  Especially if you have a well-known
webiste this improves censorship resistance since it looks as normal
surfing behaviour.

   To do so, you have to do two things:

   • Configure your webserver to forward the GNUnet HTTP traffic
   • Configure your GNUnet peer to announce the respective address

   As an example we want to use GNUnet peer running:

   • HTTP server plugin on ‘gnunet.foo.org:1080’

   • HTTPS server plugin on ‘gnunet.foo.org:4433’

   • A apache or nginx webserver on http://www.foo.org:80/
     (http://www.foo.org/)

   • A apache or nginx webserver on https://www.foo.org:443/

   And we want the webserver to accept GNUnet traffic under
‘http://www.foo.org/bar/’.  The required steps are described here:

* Menu:

* Reverse Proxy - Configure your Apache2 HTTP webserver::
* Reverse Proxy - Configure your Apache2 HTTPS webserver::
* Reverse Proxy - Configure your nginx HTTPS webserver::
* Reverse Proxy - Configure your nginx HTTP webserver::
* Reverse Proxy - Configure your GNUnet peer::


File: gnunet.info,  Node: Reverse Proxy - Configure your Apache2 HTTP webserver,  Next: Reverse Proxy - Configure your Apache2 HTTPS webserver,  Up: Configuring HTTP(S) reverse proxy functionality using Apache or nginx

3.12.24.1 Reverse Proxy - Configure your Apache2 HTTP webserver
...............................................................

First of all you need mod_proxy installed.

   Edit your webserver configuration.  Edit ‘/etc/apache2/apache2.conf’
or the site-specific configuration file.

   In the respective ‘server config’,‘virtual host’ or ‘directory’
section add the following lines:

     ProxyTimeout 300
     ProxyRequests Off
     <Location /bar/ >
     ProxyPass http://gnunet.foo.org:1080/
     ProxyPassReverse http://gnunet.foo.org:1080/
     </Location>


File: gnunet.info,  Node: Reverse Proxy - Configure your Apache2 HTTPS webserver,  Next: Reverse Proxy - Configure your nginx HTTPS webserver,  Prev: Reverse Proxy - Configure your Apache2 HTTP webserver,  Up: Configuring HTTP(S) reverse proxy functionality using Apache or nginx

3.12.24.2 Reverse Proxy - Configure your Apache2 HTTPS webserver
................................................................

We assume that you already have an HTTPS server running, if not please
check how to configure a HTTPS host.  An uncomplicated to use example is
the example configuration file for Apache2/HTTPD provided in
‘apache2/sites-available/default-ssl’.

   In the respective HTTPS ‘server config’,‘virtual host’ or ‘directory’
section add the following lines:

     SSLProxyEngine On
     ProxyTimeout 300
     ProxyRequests Off
     <Location /bar/ >
     ProxyPass https://gnunet.foo.org:4433/
     ProxyPassReverse https://gnunet.foo.org:4433/
     </Location>

More information about the apache mod_proxy configuration can be found
in the Apache documentation(1)

   ---------- Footnotes ----------

   (1) http://httpd.apache.org/docs/2.2/mod/mod_proxy.html#proxypass
(http://httpd.apache.org/docs/2.2/mod/mod_proxy.html#proxypass)


File: gnunet.info,  Node: Reverse Proxy - Configure your nginx HTTPS webserver,  Next: Reverse Proxy - Configure your nginx HTTP webserver,  Prev: Reverse Proxy - Configure your Apache2 HTTPS webserver,  Up: Configuring HTTP(S) reverse proxy functionality using Apache or nginx

3.12.24.3 Reverse Proxy - Configure your nginx HTTPS webserver
..............................................................

Since nginx does not support chunked encoding, you first of all have to
install the ‘chunkin’ module(1)

   To enable chunkin add:

     chunkin on;
     error_page 411 = @my_411_error;
     location @my_411_error {
     chunkin_resume;
     }

Edit your webserver configuration.  Edit ‘/etc/nginx/nginx.conf’ or the
site-specific configuration file.

   In the ‘server’ section add:

     location /bar/ {
     proxy_pass http://gnunet.foo.org:1080/;
     proxy_buffering off;
     proxy_connect_timeout 5; # more than http_server
     proxy_read_timeout 350; # 60 default, 300s is GNUnet's idle timeout
     proxy_http_version 1.1; # 1.0 default
     proxy_next_upstream error timeout invalid_header http_500 http_503 http_502 http_504;
     }

   ---------- Footnotes ----------

   (1) http://wiki.nginx.org/HttpChunkinModule
(http://wiki.nginx.org/HttpChunkinModule)


File: gnunet.info,  Node: Reverse Proxy - Configure your nginx HTTP webserver,  Next: Reverse Proxy - Configure your GNUnet peer,  Prev: Reverse Proxy - Configure your nginx HTTPS webserver,  Up: Configuring HTTP(S) reverse proxy functionality using Apache or nginx

3.12.24.4 Reverse Proxy - Configure your nginx HTTP webserver
.............................................................

Edit your webserver configuration.  Edit ‘/etc/nginx/nginx.conf’ or the
site-specific configuration file.

   In the ‘server’ section add:

     ssl_session_timeout 6m;
     location /bar/
     {
     proxy_pass https://gnunet.foo.org:4433/;
     proxy_buffering off;
     proxy_connect_timeout 5; # more than http_server
     proxy_read_timeout 350; # 60 default, 300s is GNUnet's idle timeout
     proxy_http_version 1.1; # 1.0 default
     proxy_next_upstream error timeout invalid_header http_500 http_503 http_502 http_504;
     }


File: gnunet.info,  Node: Reverse Proxy - Configure your GNUnet peer,  Prev: Reverse Proxy - Configure your nginx HTTP webserver,  Up: Configuring HTTP(S) reverse proxy functionality using Apache or nginx

3.12.24.5 Reverse Proxy - Configure your GNUnet peer
....................................................

To have your GNUnet peer announce the address, you have to specify the
‘EXTERNAL_HOSTNAME’ option in the ‘[transport-http_server]’ section:

     [transport-http_server]
     EXTERNAL_HOSTNAME = http://www.foo.org/bar/

and/or ‘[transport-https_server]’ section:

     [transport-https_server]
     EXTERNAL_HOSTNAME = https://www.foo.org/bar/

Now restart your webserver and your peer...


File: gnunet.info,  Node: Blacklisting peers,  Next: Configuration of the HTTP and HTTPS transport plugins,  Prev: Configuring HTTP(S) reverse proxy functionality using Apache or nginx,  Up: The graphical configuration interface

3.12.25 Blacklisting peers
--------------------------

Transport service supports to deny connecting to a specific peer of to a
specific peer with a specific transport plugin using te blacklisting
component of transport service.  With blacklisting it is possible to
deny connections to specific peers of to use a specific plugin to a
specific peer.  Peers can be blacklisted using the configuration or a
blacklist client can be asked.

   To blacklist peers using the configuration you have to add a section
to your configuration containing the peer id of the peer to blacklist
and the plugin if required.

   Examples:

   To blacklist connections to P565...  on peer AG2P... using tcp add:

     [transport-blacklist AG2PHES1BARB9IJCPAMJTFPVJ5V3A72S3F2A8SBUB8DAQ2V0O3V8G6G2JU56FHGFOHMQVKBSQFV98TCGTC3RJ1NINP82G0RC00N1520]
     P565723JO1C2HSN6J29TAQ22MN6CI8HTMUU55T0FUQG4CMDGGEQ8UCNBKUMB94GC8R9G4FB2SF9LDOBAJ6AMINBP4JHHDD6L7VD801G = tcp

   To blacklist connections to P565...  on peer AG2P... using all
plugins add:

     [transport-blacklist-AG2PHES1BARB9IJCPAMJTFPVJ5V3A72S3F2A8SBUB8DAQ2V0O3V8G6G2JU56FHGFOHMQVKBSQFV98TCGTC3RJ1NINP82G0RC00N1520]
     P565723JO1C2HSN6J29TAQ22MN6CI8HTMUU55T0FUQG4CMDGGEQ8UCNBKUMB94GC8R9G4FB2SF9LDOBAJ6AMINBP4JHHDD6L7VD801G =

   You can also add a blacklist client usign the blacklist API. On a
blacklist check, blacklisting first checks internally if the peer is
blacklisted and if not, it asks the blacklisting clients.  Clients are
asked if it is OK to connect to a peer ID, the plugin is omitted.

   On blacklist check for (peer, plugin)
   • Do we have a local blacklist entry for this peer and this plugin? 
   • YES: disallow connection 
   • Do we have a local blacklist entry for this peer and all plugins? 
   • YES: disallow connection 
   • Does one of the clients disallow? 
   • YES: disallow connection


File: gnunet.info,  Node: Configuration of the HTTP and HTTPS transport plugins,  Next: Configuring the GNU Name System,  Prev: Blacklisting peers,  Up: The graphical configuration interface

3.12.26 Configuration of the HTTP and HTTPS transport plugins
-------------------------------------------------------------

The client parts of the http and https transport plugins can be
configured to use a proxy to connect to the hostlist server.  This
functionality can be configured in the configuration file directly or
using the gnunet-setup tool.

   Both the HTTP and HTTPS clients support the following proxy types at
the moment:

   • HTTP 1.1 proxy
   • SOCKS 4/4a/5/5 with hostname

   In addition authentication at the proxy with username and password
can be configured.

   To configure proxy support for the clients in the gnunet-setup tool,
select the "transport" tab and activate the respective plugin.  Now you
can select the appropriate proxy type.  The hostname or IP address
(including port if required) has to be entered in the "Proxy hostname"
textbox.  If required, enter username and password in the "Proxy
username" and "Proxy password" boxes.  Be aware that these information
will be stored in the configuration in plain text.

   To configure these options directly in the configuration, you can
configure the following settings in the ‘[transport-http_client]’ and
‘[transport-https_client]’ section of the configuration:

     # Type of proxy server,
     # Valid values: HTTP, SOCKS4, SOCKS5, SOCKS4A, SOCKS5_HOSTNAME
     # Default: HTTP
     # PROXY_TYPE = HTTP

     # Hostname or IP of proxy server
     # PROXY =
     # User name for proxy server
     # PROXY_USERNAME =
     # User password for proxy server
     # PROXY_PASSWORD =


File: gnunet.info,  Node: Configuring the GNU Name System,  Next: Configuring the GNUnet VPN,  Prev: Configuration of the HTTP and HTTPS transport plugins,  Up: The graphical configuration interface

3.12.27 Configuring the GNU Name System
---------------------------------------

* Menu:

* Configuring system-wide DNS interception::
* Configuring the GNS nsswitch plugin::
* Configuring GNS on W32::
* GNS Proxy Setup::
* Setup of the GNS CA::
* Testing the GNS setup::


File: gnunet.info,  Node: Configuring system-wide DNS interception,  Next: Configuring the GNS nsswitch plugin,  Up: Configuring the GNU Name System

3.12.27.1 Configuring system-wide DNS interception
..................................................

Before you install GNUnet, make sure you have a user and group ’gnunet’
as well as an empty group ’gnunetdns’.

   When using GNUnet with system-wide DNS interception, it is absolutely
necessary for all GNUnet service processes to be started by
‘gnunet-service-arm’ as user and group ’gnunet’.  You also need to be
sure to run ‘make install’ as root (or use the ‘sudo’ option to
configure) to grant GNUnet sufficient privileges.

   With this setup, all that is required for enabling system-wide DNS
interception is for some GNUnet component (VPN or GNS) to request it.
The ‘gnunet-service-dns’ will then start helper programs that will make
the necessary changes to your firewall (‘iptables’) rules.

   Note that this will NOT work if your system sends out DNS traffic to
a link-local IPv6 address, as in this case GNUnet can intercept the
traffic, but not inject the responses from the link-local IPv6 address.
Hence you cannot use system-wide DNS interception in conjunction with
link-local IPv6-based DNS servers.  If such a DNS server is used, it
will bypass GNUnet’s DNS traffic interception.

   Using the GNU Name System (GNS) requires two different configuration
steps.  First of all, GNS needs to be integrated with the operating
system.  Most of this section is about the operating system level
integration.

   The remainder of this chapter will detail the various methods for
configuring the use of GNS with your operating system.

   At this point in time you have different options depending on your
OS:

Use the gnunet-gns-proxy This approach works for all operating
     systems and is likely the easiest.  However, it enables GNS only
     for browsers, not for other applications that might be using DNS,
     such as SSH. Still, using the proxy is required for using HTTP with
     GNS and is thus recommended for all users.  To do this, you simply
     have to run the ‘gnunet-gns-proxy-setup-ca’ script as the user who
     will run the browser (this will create a GNS certificate authority
     (CA) on your system and import its key into your browser), then
     start ‘gnunet-gns-proxy’ and inform your browser to use the Socks5
     proxy which ‘gnunet-gns-proxy’ makes available by default on port
     7777.
Use a nsswitch plugin (recommended on GNU systems)
     This approach has the advantage of offering fully personalized
     resolution even on multi-user systems.  A potential disadvantage is
     that some applications might be able to bypass GNS.
Use a W32 resolver plugin (recommended on W32)
     This is currently the only option on W32 systems.
Use system-wide DNS packet interception
     This approach is recommended for the GNUnet VPN. It can be used to
     handle GNS at the same time; however, if you only use this method,
     you will only get one root zone per machine (not so great for
     multi-user systems).

   You can combine system-wide DNS packet interception with the nsswitch
plugin.  The setup of the system-wide DNS interception is described
here.  All of the other GNS-specific configuration steps are described
in the following sections.


File: gnunet.info,  Node: Configuring the GNS nsswitch plugin,  Next: Configuring GNS on W32,  Prev: Configuring system-wide DNS interception,  Up: Configuring the GNU Name System

3.12.27.2 Configuring the GNS nsswitch plugin
.............................................

The Name Service Switch (NSS) is a facility in Unix-like operating
systems (1) that provides a variety of sources for common configuration
databases and name resolution mechanisms.  A superuser (system
administrator) usually configures the operating system’s name services
using the file ‘/etc/nsswitch.conf’.

   GNS provides a NSS plugin to integrate GNS name resolution with the
operating system’s name resolution process.  To use the GNS NSS plugin
you have to either

   • install GNUnet as root or
   • compile GNUnet with the ‘--with-sudo=yes’ switch.

   Name resolution is controlled by the _hosts_ section in the NSS
configuration.  By default this section first performs a lookup in the
‘/etc/hosts’ file and then in DNS. The nsswitch file should contain a
line similar to:

     hosts: files dns [NOTFOUND=return] mdns4_minimal mdns4

Here the GNS NSS plugin can be added to perform a GNS lookup before
performing a DNS lookup.  The GNS NSS plugin has to be added to the
"hosts" section in ‘/etc/nsswitch.conf’ file before DNS related plugins:

     ...
     hosts: files gns [NOTFOUND=return] dns mdns4_minimal mdns4
     ...

The ‘NOTFOUND=return’ will ensure that if a ‘.gnu’ name is not found in
GNS it will not be queried in DNS.

   ---------- Footnotes ----------

   (1) More accurate: NSS is a functionality of the GNU C Library


File: gnunet.info,  Node: Configuring GNS on W32,  Next: GNS Proxy Setup,  Prev: Configuring the GNS nsswitch plugin,  Up: Configuring the GNU Name System

3.12.27.3 Configuring GNS on W32
................................

This document is a guide to configuring GNU Name System on
W32-compatible platforms.

   After GNUnet is installed, run the w32nsp-install tool:

     w32nsp-install.exe libw32nsp-0.dll

(’0’ is the library version of W32 NSP; it might increase in the future,
change the invocation accordingly).

   This will install GNS namespace provider into the system and allow
other applications to resolve names that end in ’*gnu*’ and ’*zkey*’.
Note that namespace provider requires gnunet-gns-helper-service-w32 to
be running, as well as gns service itself (and its usual dependencies).

   Namespace provider is hardcoded to connect to *127.0.0.1:5353*, and
this is where gnunet-gns-helper-service-w32 should be listening to (and
is configured to listen to by default).

   To uninstall the provider, run:

     w32nsp-uninstall.exe

(uses provider GUID to uninstall it, does not need a dll name).

   Note that while MSDN claims that other applications will only be able
to use the new namespace provider after re-starting, in reality they
might stat to use it without that.  Conversely, they might stop using
the provider after it’s been uninstalled, even if they were not
re-started.  W32 will not permit namespace provider library to be
deleted or overwritten while the provider is installed, and while there
is at least one process still using it (even after it was uninstalled).


File: gnunet.info,  Node: GNS Proxy Setup,  Next: Setup of the GNS CA,  Prev: Configuring GNS on W32,  Up: Configuring the GNU Name System

3.12.27.4 GNS Proxy Setup
.........................

When using the GNU Name System (GNS) to browse the WWW, there are
several issues that can be solved by adding the GNS Proxy to your setup:

   • If the target website does not support GNS, it might assume that it
     is operating under some name in the legacy DNS system (such as
     example.com).  It may then attempt to set cookies for that domain,
     and the web server might expect a ‘Host: example.com’ header in the
     request from your browser.  However, your browser might be using
     ‘example.gnu’ for the ‘Host’ header and might only accept (and
     send) cookies for ‘example.gnu’.  The GNS Proxy will perform the
     necessary translations of the hostnames for cookies and HTTP
     headers (using the LEHO record for the target domain as the desired
     substitute).

   • If using HTTPS, the target site might include an SSL certificate
     which is either only valid for the LEHO domain or might match a
     TLSA record in GNS. However, your browser would expect a valid
     certificate for ‘example.gnu’, not for some legacy domain name.
     The proxy will validate the certificate (either against LEHO or
     TLSA) and then on-the-fly produce a valid certificate for the
     exchange, signed by your own CA. Assuming you installed the CA of
     your proxy in your browser’s certificate authority list, your
     browser will then trust the HTTPS/SSL/TLS connection, as the
     hostname mismatch is hidden by the proxy.

   • Finally, the proxy will in the future indicate to the server that
     it speaks GNS, which will enable server operators to deliver
     GNS-enabled web sites to your browser (and continue to deliver
     legacy links to legacy browsers)


File: gnunet.info,  Node: Setup of the GNS CA,  Next: Testing the GNS setup,  Prev: GNS Proxy Setup,  Up: Configuring the GNU Name System

3.12.27.5 Setup of the GNS CA
.............................

First you need to create a CA certificate that the proxy can use.  To do
so use the provided script gnunet-gns-proxy-ca:

     $ gnunet-gns-proxy-setup-ca

This will create a personal certification authority for you and add this
authority to the firefox and chrome database.  The proxy will use the
this CA certificate to generate ‘*.gnu’ client certificates on the fly.

   Note that the proxy uses libcurl.  Make sure your version of libcurl
uses GnuTLS and NOT OpenSSL. The proxy will not work with libcurl
compiled against OpenSSL.

   You can check the configuration your libcurl was build with by
running:

     curl --version

   the output will look like this (without the linebreaks):

     gnurl --version
     curl 7.56.0 (x86_64-unknown-linux-gnu) libcurl/7.56.0 \
     GnuTLS/3.5.13 zlib/1.2.11 libidn2/2.0.4
     Release-Date: 2017-10-08
     Protocols: http https
     Features: AsynchDNS IDN IPv6 Largefile NTLM SSL libz \
     TLS-SRP UnixSockets HTTPS-proxy


File: gnunet.info,  Node: Testing the GNS setup,  Prev: Setup of the GNS CA,  Up: Configuring the GNU Name System

3.12.27.6 Testing the GNS setup
...............................

Now for testing purposes we can create some records in our zone to test
the SSL functionality of the proxy:

     $ gnunet-identity -C test
     $ gnunet-namestore -a -e "1 d" -n "homepage" \
       -t A -V 131.159.74.67 -z test
     $ gnunet-namestore -a -e "1 d" -n "homepage" \
       -t LEHO -V "gnunet.org" -z test

At this point we can start the proxy.  Simply execute

     $ gnunet-gns-proxy

Configure your browser to use this SOCKSv5 proxy on port 7777 and visit
this link.  If you use ‘Firefox’ (or one of its deriviates/forks such as
Icecat) you also have to go to ‘about:config’ and set the key
‘network.proxy.socks_remote_dns’ to ‘true’.

   When you visit ‘https://homepage.test/’, you should get to the
‘https://gnunet.org/’ frontpage and the browser (with the correctly
configured proxy) should give you a valid SSL certificate for
‘homepage.gnu’ and no warnings.  It should look like this:


File: gnunet.info,  Node: Configuring the GNUnet VPN,  Next: Bandwidth Configuration,  Prev: Configuring the GNU Name System,  Up: The graphical configuration interface

3.12.28 Configuring the GNUnet VPN
----------------------------------

* Menu:

* IPv4 address for interface::
* IPv6 address for interface::
* Configuring the GNUnet VPN DNS::
* Configuring the GNUnet VPN Exit Service::
* IP Address of external DNS resolver::
* IPv4 address for Exit interface::
* IPv6 address for Exit interface::

Before configuring the GNUnet VPN, please make sure that system-wide DNS
interception is configured properly as described in the section on the
GNUnet DNS setup.  *note Configuring the GNU Name System::, if you
haven’t done so already.

   The default options for the GNUnet VPN are usually sufficient to use
GNUnet as a Layer 2 for your Internet connection.  However, what you
always have to specify is which IP protocol you want to tunnel: IPv4,
IPv6 or both.  Furthermore, if you tunnel both, you most likely should
also tunnel all of your DNS requests.  You theoretically can tunnel
"only" your DNS traffic, but that usually makes little sense.

   The other options as shown on the gnunet-setup tool are:


File: gnunet.info,  Node: IPv4 address for interface,  Next: IPv6 address for interface,  Up: Configuring the GNUnet VPN

3.12.28.1 IPv4 address for interface
....................................

This is the IPv4 address the VPN interface will get.  You should pick an
’private’ IPv4 network that is not yet in use for you system.  For
example, if you use ‘10.0.0.1/255.255.0.0’ already, you might use
‘10.1.0.1/255.255.0.0’.  If you use ‘10.0.0.1/255.0.0.0’ already, then
you might use ‘192.168.0.1/255.255.0.0’.  If your system is not in a
private IP-network, using any of the above will work fine.  You should
try to make the mask of the address big enough (‘255.255.0.0’ or, even
better, ‘255.0.0.0’) to allow more mappings of remote IP Addresses into
this range.  However, even a ‘255.255.255.0’ mask will suffice for most
users.


File: gnunet.info,  Node: IPv6 address for interface,  Next: Configuring the GNUnet VPN DNS,  Prev: IPv4 address for interface,  Up: Configuring the GNUnet VPN

3.12.28.2 IPv6 address for interface
....................................

The IPv6 address the VPN interface will get.  Here you can specify any
non-link-local address (the address should not begin with ‘fe80:’).  A
subnet Unique Local Unicast (‘fd00::/8’ prefix) that you are currently
not using would be a good choice.


File: gnunet.info,  Node: Configuring the GNUnet VPN DNS,  Next: Configuring the GNUnet VPN Exit Service,  Prev: IPv6 address for interface,  Up: Configuring the GNUnet VPN

3.12.28.3 Configuring the GNUnet VPN DNS
........................................

To resolve names for remote nodes, activate the DNS exit option.


File: gnunet.info,  Node: Configuring the GNUnet VPN Exit Service,  Next: IP Address of external DNS resolver,  Prev: Configuring the GNUnet VPN DNS,  Up: Configuring the GNUnet VPN

3.12.28.4 Configuring the GNUnet VPN Exit Service
.................................................

If you want to allow other users to share your Internet connection (yes,
this may be dangerous, just as running a Tor exit node) or want to
provide access to services on your host (this should be less dangerous,
as long as those services are secure), you have to enable the GNUnet
exit daemon.

   You then get to specify which exit functions you want to provide.  By
enabling the exit daemon, you will always automatically provide exit
functions for manually configured local services (this component of the
system is under development and not documented further at this time).
As for those services you explicitly specify the target IP address and
port, there is no significant security risk in doing so.

   Furthermore, you can serve as a DNS, IPv4 or IPv6 exit to the
Internet.  Being a DNS exit is usually pretty harmless.  However,
enabling IPv4 or IPv6-exit without further precautions may enable
adversaries to access your local network, send spam, attack other
systems from your Internet connection and to other mischief that will
appear to come from your machine.  This may or may not get you into
legal trouble.  If you want to allow IPv4 or IPv6-exit functionality,
you should strongly consider adding additional firewall rules manually
to protect your local network and to restrict outgoing TCP traffic (i.e.
by not allowing access to port 25).  While we plan to improve
exit-filtering in the future, you’re currently on your own here.
Essentially, be prepared for any kind of IP-traffic to exit the
respective TUN interface (and GNUnet will enable IP-forwarding and NAT
for the interface automatically).

   Additional configuration options of the exit as shown by the
gnunet-setup tool are:


File: gnunet.info,  Node: IP Address of external DNS resolver,  Next: IPv4 address for Exit interface,  Prev: Configuring the GNUnet VPN Exit Service,  Up: Configuring the GNUnet VPN

3.12.28.5 IP Address of external DNS resolver
.............................................

If DNS traffic is to exit your machine, it will be send to this DNS
resolver.  You can specify an IPv4 or IPv6 address.


File: gnunet.info,  Node: IPv4 address for Exit interface,  Next: IPv6 address for Exit interface,  Prev: IP Address of external DNS resolver,  Up: Configuring the GNUnet VPN

3.12.28.6 IPv4 address for Exit interface
.........................................

This is the IPv4 address the Interface will get.  Make the mask of the
address big enough (255.255.0.0 or, even better, 255.0.0.0) to allow
more mappings of IP addresses into this range.  As for the VPN
interface, any unused, private IPv4 address range will do.


File: gnunet.info,  Node: IPv6 address for Exit interface,  Prev: IPv4 address for Exit interface,  Up: Configuring the GNUnet VPN

3.12.28.7 IPv6 address for Exit interface
.........................................

The public IPv6 address the interface will get.  If your kernel is not a
very recent kernel and you are willing to manually enable IPv6-NAT, the
IPv6 address you specify here must be a globally routed IPv6 address of
your host.

   Suppose your host has the address ‘2001:4ca0::1234/64’, then using
‘2001:4ca0::1:0/112’ would be fine (keep the first 64 bits, then change
at least one bit in the range before the bitmask, in the example above
we changed bit 111 from 0 to 1).

   You may also have to configure your router to route traffic for the
entire subnet (‘2001:4ca0::1:0/112’ for example) through your computer
(this should be automatic with IPv6, but obviously anything can be
disabled).


File: gnunet.info,  Node: Bandwidth Configuration,  Next: Configuring NAT,  Prev: Configuring the GNUnet VPN,  Up: The graphical configuration interface

3.12.29 Bandwidth Configuration
-------------------------------

You can specify how many bandwidth GNUnet is allowed to use to receive
and send data.  This is important for users with limited bandwidth or
traffic volume.


File: gnunet.info,  Node: Configuring NAT,  Next: Peer configuration for distributions,  Prev: Bandwidth Configuration,  Up: The graphical configuration interface

3.12.30 Configuring NAT
-----------------------

Most hosts today do not have a normal global IP address but instead are
behind a router performing Network Address Translation (NAT) which
assigns each host in the local network a private IP address.  As a
result, these machines cannot trivially receive inbound connections from
the Internet.  GNUnet supports NAT traversal to enable these machines to
receive incoming connections from other peers despite their limitations.

   In an ideal world, you can press the "Attempt automatic
configuration" button in gnunet-setup to automatically configure your
peer correctly.  Alternatively, your distribution might have already
triggered this automatic configuration during the installation process.
However, automatic configuration can fail to determine the optimal
settings, resulting in your peer either not receiving as many
connections as possible, or in the worst case it not connecting to the
network at all.

   To manually configure the peer, you need to know a few things about
your network setup.  First, determine if you are behind a NAT in the
first place.  This is always the case if your IP address starts with
"10.*" or "192.168.*".  Next, if you have control over your NAT router,
you may choose to manually configure it to allow GNUnet traffic to your
host.  If you have configured your NAT to forward traffic on ports 2086
(and possibly 1080) to your host, you can check the "NAT ports have been
opened manually" option, which corresponds to the "PUNCHED_NAT" option
in the configuration file.  If you did not punch your NAT box, it may
still be configured to support UPnP, which allows GNUnet to
automatically configure it.  In that case, you need to install the
"upnpc" command, enable UPnP (or PMP) on your NAT box and set the
"Enable NAT traversal via UPnP or PMP" option (corresponding to
"ENABLE_UPNP" in the configuration file).

   Some NAT boxes can be traversed using the autonomous NAT traversal
method.  This requires certain GNUnet components to be installed with
"SUID" prividledges on your system (so if you’re installing on a system
you do not have administrative rights to, this will not work).  If you
installed as ’root’, you can enable autonomous NAT traversal by checking
the "Enable NAT traversal using ICMP method".  The ICMP method requires
a way to determine your NAT’s external (global) IP address.  This can be
done using either UPnP, DynDNS, or by manual configuration.  If you have
a DynDNS name or know your external IP address, you should enter that
name under "External (public) IPv4 address" (which corresponds to the
"EXTERNAL_ADDRESS" option in the configuration file).  If you leave the
option empty, GNUnet will try to determine your external IP address
automatically (which may fail, in which case autonomous NAT traversal
will then not work).

   Finally, if you yourself are not behind NAT but want to be able to
connect to NATed peers using autonomous NAT traversal, you need to check
the "Enable connecting to NATed peers using ICMP method" box.


File: gnunet.info,  Node: Peer configuration for distributions,  Prev: Configuring NAT,  Up: The graphical configuration interface

3.12.31 Peer configuration for distributions
--------------------------------------------

The "GNUNET_DATA_HOME" in "[path]" in ‘/etc/gnunet.conf’ should be
manually set to "/var/lib/gnunet/data/" as the default
"~/.local/share/gnunet/" is probably not that appropriate in this case.
Similarly, distributions may consider pointing "GNUNET_RUNTIME_DIR" to
"/var/run/gnunet/" and "GNUNET_HOME" to "/var/lib/gnunet/".  Also,
should a distribution decide to override system defaults, all of these
changes should be done in a custom ‘/etc/gnunet.conf’ and not in the
files in the ‘config.d/’ directory.

   Given the proposed access permissions, the "gnunet-setup" tool must
be run as use "gnunet" (and with option "-c /etc/gnunet.conf" so that it
modifies the system configuration).  As always, gnunet-setup should be
run after the GNUnet peer was stopped using "gnunet-arm -e".
Distributions might want to include a wrapper for gnunet-setup that
allows the desktop-user to "sudo" (i.e.  using gtksudo) to the "gnunet"
user account and then runs "gnunet-arm -e", "gnunet-setup" and
"gnunet-arm -s" in sequence.


File: gnunet.info,  Node: How to start and stop a GNUnet peer,  Prev: The graphical configuration interface,  Up: GNUnet Installation Handbook

3.13 How to start and stop a GNUnet peer
========================================

This section describes how to start a GNUnet peer.  It assumes that you
have already compiled and installed GNUnet and its’ dependencies.
Before you start a GNUnet peer, you may want to create a configuration
file using gnunet-setup (but you do not have to).  Sane defaults should
exist in your ‘$GNUNET_PREFIX/share/gnunet/config.d/’ directory, so in
practice you could simply start without any configuration.  If you want
to configure your peer later, you need to stop it before invoking the
‘gnunet-setup’ tool to customize further and to test your configuration
(‘gnunet-setup’ has build-in test functions).

   The most important option you might have to still set by hand is in
[PATHS]. Here, you use the option "GNUNET_HOME" to specify the path
where GNUnet should store its data.  It defaults to ‘$HOME/’, which
again should work for most users.  Make sure that the directory
specified as GNUNET_HOME is writable to the user that you will use to
run GNUnet (note that you can run frontends using other users,
GNUNET_HOME must only be accessible to the user used to run the
background processes).

   You will also need to make one central decision: should all of GNUnet
be run under your normal UID, or do you want distinguish between
system-wide (user-independent) GNUnet services and personal GNUnet
services.  The multi-user setup is slightly more complicated, but also
more secure and generally recommended.

* Menu:

* The Single-User Setup::
* The Multi-User Setup::
* Killing GNUnet services::
* Access Control for GNUnet::


File: gnunet.info,  Node: The Single-User Setup,  Next: The Multi-User Setup,  Up: How to start and stop a GNUnet peer

3.13.1 The Single-User Setup
----------------------------

For the single-user setup, you do not need to do anything special and
can just start the GNUnet background processes using ‘gnunet-arm’.  By
default, GNUnet looks in ‘~/.config/gnunet.conf’ for a configuration (or
‘$XDG_CONFIG_HOME/gnunet.conf’ if ‘$XDG_CONFIG_HOME’ is defined).  If
your configuration lives elsewhere, you need to pass the ‘-c FILENAME’
option to all GNUnet commands.

   Assuming the configuration file is called ‘~/.config/gnunet.conf’,
you start your peer using the ‘gnunet-arm’ command (say as user
‘gnunet’) using:

     gnunet-arm -c ~/.config/gnunet.conf -s

The "-s" option here is for "start".  The command should return almost
instantly.  If you want to stop GNUnet, you can use:

     gnunet-arm -c ~/.config/gnunet.conf -e

The "-e" option here is for "end".

   Note that this will only start the basic peer, no actual applications
will be available.  If you want to start the file-sharing service, use
(after starting GNUnet):

     gnunet-arm -c ~/.config/gnunet.conf -i fs

The "-i fs" option here is for "initialize" the "fs" (file-sharing)
application.  You can also selectively kill only file-sharing support
using

     gnunet-arm -c ~/.config/gnunet.conf -k fs

Assuming that you want certain services (like file-sharing) to be always
automatically started whenever you start GNUnet, you can activate them
by setting "FORCESTART=YES" in the respective section of the
configuration file (for example, "[fs]").  Then GNUnet with file-sharing
support would be started whenever you enter:

     gnunet-arm -c ~/.config/gnunet.conf -s

Alternatively, you can combine the two options:

     gnunet-arm -c ~/.config/gnunet.conf -s -i fs

Using ‘gnunet-arm’ is also the preferred method for initializing GNUnet
from ‘init’.

   Finally, you should edit your ‘crontab’ (using the ‘crontab’ command)
and insert a line 

     @reboot gnunet-arm -c ~/.config/gnunet.conf -s

   to automatically start your peer whenever your system boots.


File: gnunet.info,  Node: The Multi-User Setup,  Next: Killing GNUnet services,  Prev: The Single-User Setup,  Up: How to start and stop a GNUnet peer

3.13.2 The Multi-User Setup
---------------------------

This requires you to create a user ‘gnunet’ and an additional group
‘gnunetdns’, prior to running ‘make install’ during installation.  Then,
you create a configuration file ‘/etc/gnunet.conf’ which should contain
the lines: 

     [arm]
     SYSTEM_ONLY = YES
     USER_ONLY = NO

Then, perform the same steps to run GNUnet as in the per-user
configuration, except as user ‘gnunet’ (including the ‘crontab’
installation).  You may also want to run ‘gnunet-setup’ to configure
your peer (databases, etc.).  Make sure to pass ‘-c /etc/gnunet.conf’ to
all commands.  If you run ‘gnunet-setup’ as user ‘gnunet’, you might
need to change permissions on ‘/etc/gnunet.conf’ so that the ‘gnunet’
user can write to the file (during setup).

   Afterwards, you need to perform another setup step for each normal
user account from which you want to access GNUnet.  First, grant the
normal user (‘$USER’) permission to the group gnunet:

     # adduser $USER gnunet

Then, create a configuration file in ‘~/.config/gnunet.conf’ for the
$USER with the lines:

     [arm]
     SYSTEM_ONLY = NO
     USER_ONLY = YES

This will ensure that ‘gnunet-arm’ when started by the normal user will
only run services that are per-user, and otherwise rely on the
system-wide services.  Note that the normal user may run gnunet-setup,
but the configuration would be ineffective as the system-wide services
will use ‘/etc/gnunet.conf’ and ignore options set by individual users.

   Again, each user should then start the peer using ‘gnunet-arm -s’ —
and strongly consider adding logic to start the peer automatically to
their crontab.

   Afterwards, you should see two (or more, if you have more than one
USER) ‘gnunet-service-arm’ processes running in your system.


File: gnunet.info,  Node: Killing GNUnet services,  Next: Access Control for GNUnet,  Prev: The Multi-User Setup,  Up: How to start and stop a GNUnet peer

3.13.3 Killing GNUnet services
------------------------------

It is not necessary to stop GNUnet services explicitly when shutting
down your computer.

   It should be noted that manually killing "most" of the
‘gnunet-service’ processes is generally not a successful method for
stopping a peer (since ‘gnunet-service-arm’ will instantly restart
them).  The best way to explicitly stop a peer is using ‘gnunet-arm -e’;
note that the per-user services may need to be terminated before the
system-wide services will terminate normally.


File: gnunet.info,  Node: Access Control for GNUnet,  Prev: Killing GNUnet services,  Up: How to start and stop a GNUnet peer

3.13.4 Access Control for GNUnet
--------------------------------

This chapter documents how we plan to make access control work within
the GNUnet system for a typical peer.  It should be read as a
best-practice installation guide for advanced users and builders of
binary distributions.  The recommendations in this guide apply to
POSIX-systems with full support for UNIX domain sockets only.

   Note that this is an advanced topic.  The discussion presumes a very
good understanding of users, groups and file permissions.  Normal users
on hosts with just a single user can just install GNUnet under their own
account (and possibly allow the installer to use SUDO to grant
additional permissions for special GNUnet tools that need additional
rights).  The discussion below largely applies to installations where
multiple users share a system and to installations where the best
possible security is paramount.

   A typical GNUnet system consists of components that fall into four
categories:

User interfaces
     User interfaces are not security sensitive and are supposed to be
     run and used by normal system users.  The GTK GUIs and most
     command-line programs fall into this category.  Some command-line
     tools (like gnunet-transport) should be excluded as they offer
     low-level access that normal users should not need.
System services and support tools
     System services should always run and offer services that can then
     be accessed by the normal users.  System services do not require
     special permissions, but as they are not specific to a particular
     user, they probably should not run as a particular user.  Also,
     there should typically only be one GNUnet peer per host.  System
     services include the gnunet-service and gnunet-daemon programs;
     support tools include command-line programs such as gnunet-arm.
Priviledged helpers
     Some GNUnet components require root rights to open raw sockets or
     perform other special operations.  These gnunet-helper binaries are
     typically installed SUID and run from services or daemons.
Critical services
     Some GNUnet services (such as the DNS service) can manipulate the
     service in deep and possibly highly security sensitive ways.  For
     example, the DNS service can be used to intercept and alter any DNS
     query originating from the local machine.  Access to the APIs of
     these critical services and their priviledged helpers must be
     tightly controlled.

* Menu:

* Recommendation - Disable access to services via TCP::
* Recommendation - Run most services as system user "gnunet"::
* Recommendation - Control access to services using group "gnunet"::
* Recommendation - Limit access to certain SUID binaries by group "gnunet"::
* Recommendation - Limit access to critical gnunet-helper-dns to group "gnunetdns"::
* Differences between "make install" and these recommendations::


File: gnunet.info,  Node: Recommendation - Disable access to services via TCP,  Next: Recommendation - Run most services as system user "gnunet",  Up: Access Control for GNUnet

3.13.4.1 Recommendation - Disable access to services via TCP
............................................................

GNUnet services allow two types of access: via TCP socket or via UNIX
domain socket.  If the service is available via TCP, access control can
only be implemented by restricting connections to a particular range of
IP addresses.  This is acceptable for non-critical services that are
supposed to be available to all users on the local system or local
network.  However, as TCP is generally less efficient and it is rarely
the case that a single GNUnet peer is supposed to serve an entire local
network, the default configuration should disable TCP access to all
GNUnet services on systems with support for UNIX domain sockets.  As of
GNUnet 0.9.2, configuration files with TCP access disabled should be
generated by default.  Users can re-enable TCP access to particular
services simply by specifying a non-zero port number in the section of
the respective service.


File: gnunet.info,  Node: Recommendation - Run most services as system user "gnunet",  Next: Recommendation - Control access to services using group "gnunet",  Prev: Recommendation - Disable access to services via TCP,  Up: Access Control for GNUnet

3.13.4.2 Recommendation - Run most services as system user "gnunet"
...................................................................

GNUnet’s main services should be run as a separate user "gnunet" in a
special group "gnunet".  The user "gnunet" should start the peer using
"gnunet-arm -s" during system startup.  The home directory for this user
should be ‘/var/lib/gnunet’ and the configuration file should be
‘/etc/gnunet.conf’.  Only the ‘gnunet’ user should have the right to
access ‘/var/lib/gnunet’ (_mode: 700_).


File: gnunet.info,  Node: Recommendation - Control access to services using group "gnunet",  Next: Recommendation - Limit access to certain SUID binaries by group "gnunet",  Prev: Recommendation - Run most services as system user "gnunet",  Up: Access Control for GNUnet

3.13.4.3 Recommendation - Control access to services using group "gnunet"
.........................................................................

Users that should be allowed to use the GNUnet peer should be added to
the group "gnunet".  Using GNUnet’s access control mechanism for UNIX
domain sockets, those services that are considered useful to ordinary
users should be made available by setting "UNIX_MATCH_GID=YES" for those
services.  Again, as shipped, GNUnet provides reasonable defaults.
Permissions to access the transport and core subsystems might
additionally be granted without necessarily causing security concerns.
Some services, such as DNS, must NOT be made accessible to the "gnunet"
group (and should thus only be accessible to the "gnunet" user and
services running with this UID).


File: gnunet.info,  Node: Recommendation - Limit access to certain SUID binaries by group "gnunet",  Next: Recommendation - Limit access to critical gnunet-helper-dns to group "gnunetdns",  Prev: Recommendation - Control access to services using group "gnunet",  Up: Access Control for GNUnet

3.13.4.4 Recommendation - Limit access to certain SUID binaries by group "gnunet"
.................................................................................

Most of GNUnet’s SUID binaries should be safe even if executed by normal
users.  However, it is possible to reduce the risk a little bit more by
making these binaries owned by the group "gnunet" and restricting their
execution to user of the group "gnunet" as well (4750).


File: gnunet.info,  Node: Recommendation - Limit access to critical gnunet-helper-dns to group "gnunetdns",  Next: Differences between "make install" and these recommendations,  Prev: Recommendation - Limit access to certain SUID binaries by group "gnunet",  Up: Access Control for GNUnet

3.13.4.5 Recommendation - Limit access to critical gnunet-helper-dns to group "gnunetdns"
.........................................................................................

A special group "gnunetdns" should be created for controlling access to
the "gnunet-helper-dns".  The binary should then be owned by root and be
in group "gnunetdns" and be installed SUID and only be group-executable
(2750).  Note that the group "gnunetdns" should have no users in it at
all, ever.  The "gnunet-service-dns" program should be executed by user
"gnunet" (via gnunet-service-arm) with the binary owned by the user
"root" and the group "gnunetdns" and be SGID (2700).  This way, *only*
"gnunet-service-dns" can change its group to "gnunetdns" and execute the
helper, and the helper can then run as root (as per SUID). Access to the
API offered by "gnunet-service-dns" is in turn restricted to the user
"gnunet" (not the group!), which means that only "benign" services can
manipulate DNS queries using "gnunet-service-dns".


File: gnunet.info,  Node: Differences between "make install" and these recommendations,  Prev: Recommendation - Limit access to critical gnunet-helper-dns to group "gnunetdns",  Up: Access Control for GNUnet

3.13.4.6 Differences between "make install" and these recommendations
.....................................................................

The current build system does not set all permissions automatically
based on the recommendations above.  In particular, it does not use the
group "gnunet" at all (so setting gnunet-helpers other than the
gnunet-helper-dns to be owned by group "gnunet" must be done manually).
Furthermore, ’make install’ will silently fail to set the DNS binaries
to be owned by group "gnunetdns" unless that group already exists (!).
An alternative name for the "gnunetdns" group can be specified using the
‘--with-gnunetdns=GRPNAME’ configure option.


File: gnunet.info,  Node: Using GNUnet,  Next: GNUnet Contributors Handbook,  Prev: GNUnet Installation Handbook,  Up: Top

4 Using GNUnet
**************

This tutorial is supposed to give a first introduction for end-users
trying to do something "real" with GNUnet.  Installation and
configuration are specifically outside of the scope of this tutorial.
Instead, we start by briefly checking that the installation works, and
then dive into uncomplicated, concrete practical things that can be done
with the network.

   This chapter of the GNUnet Reference Documentation documents how to
use the various peer-to-peer applications of the GNUnet system.  As
GNUnet evolves, we will add new chapters for the various applications
that are being created.

   Comments and extensions of this documentation are always welcome.

* Menu:

* Checking the Installation::
* First steps - File-sharing::
* First steps - Using the GNU Name System::
* First steps - Using GNUnet Conversation::
* First steps - Using the GNUnet VPN::
* File-sharing::
* The GNU Name System::
* Using the Virtual Public Network::


File: gnunet.info,  Node: Checking the Installation,  Next: First steps - File-sharing,  Up: Using GNUnet

4.1 Checking the Installation
=============================

This section describes a quick casual way to check if your GNUnet
installation works.  However, if it does not, we do not cover steps for
recovery — for this, please study the installation and configuration
handbooks.

* Menu:

* gnunet-gtk::
* Statistics::
* Peer Information::


File: gnunet.info,  Node: gnunet-gtk,  Next: Statistics,  Up: Checking the Installation

4.1.1 gnunet-gtk
----------------

The ‘gnunet-gtk’ package contains several graphical user interfaces for
the respective GNUnet applications.  Those currently are:

   • Statistics
   • Peer Information
   • GNU Name System
   • File Sharing
   • Identity Management
   • Conversation


File: gnunet.info,  Node: Statistics,  Next: Peer Information,  Prev: gnunet-gtk,  Up: Checking the Installation

4.1.2 Statistics
----------------

First, you should launch the graphical user interface.  You can do this
from the command-line by typing

     $ gnunet-statistics-gtk

   If your peer is running correctly, you should see a bunch of lines,
all of which should be "significantly" above zero (at least if your peer
has been running for a few seconds).  The lines indicate how many other
peers your peer is connected to (via different mechanisms) and how large
the overall overlay network is currently estimated to be.  The X-axis
represents time (in seconds since the start of ‘gnunet-gtk’).

   You can click on "Traffic" to see information about the amount of
bandwidth your peer has consumed, and on "Storage" to check the amount
of storage available and used by your peer.  Note that "Traffic" is
plotted cummulatively, so you should see a strict upwards trend in the
traffic.


File: gnunet.info,  Node: Peer Information,  Prev: Statistics,  Up: Checking the Installation

4.1.3 Peer Information
----------------------

First, you should launch the graphical user interface.  You can do this
from the command-line by typing

     $ gnunet-peerinfo-gtk

   Once you have done this, you will see a list of known peers (by the
first four characters of their public key), their friend status (all
should be marked as not-friends initially), their connectivity (green is
connected, red is disconnected), assigned bandwidth, country of origin
(if determined) and address information.  If hardly any peers are listed
and/or if there are very few peers with a green light for connectivity,
there is likely a problem with your network configuration.


File: gnunet.info,  Node: First steps - File-sharing,  Next: First steps - Using the GNU Name System,  Prev: Checking the Installation,  Up: Using GNUnet

4.2 First steps - File-sharing
==============================

This chapter describes first steps for file-sharing with GNUnet.  To
start, you should launch ‘gnunet-fs-gtk’.

   As we want to be sure that the network contains the data that we are
looking for for testing, we need to begin by publishing a file.

* Menu:

* Publishing::
* Searching::
* Downloading::


File: gnunet.info,  Node: Publishing,  Next: Searching,  Up: First steps - File-sharing

4.2.1 Publishing
----------------

To publish a file, select "File Sharing" in the menu bar just below the
"Statistics" icon, and then select "Publish" from the menu.

   Afterwards, the following publishing dialog will appear:

   In this dialog, select the "Add File" button.  This will open a file
selection dialog:

   Now, you should select a file from your computer to be published on
GNUnet.  To see more of GNUnet’s features later, you should pick a PNG
or JPEG file this time.  You can leave all of the other options in the
dialog unchanged.  Confirm your selection by pressing the "OK" button in
the bottom right corner.  Now, you will briefly see a "Messages..."
dialog pop up, but most likely it will be too short for you to really
read anything.  That dialog is showing you progress information as
GNUnet takes a first look at the selected file(s).  For a normal image,
this is virtually instant, but if you later import a larger directory
you might be interested in the progress dialog and potential errors that
might be encountered during processing.  After the progress dialog
automatically disappears, your file should now appear in the publishing
dialog:

   Now, select the file (by clicking on the file name) and then click
the "Edit" button.  This will open the editing dialog:

   In this dialog, you can see many details about your file.  In the top
left area, you can see meta data extracted about the file, such as the
original filename, the mimetype and the size of the image.  In the top
right, you should see a preview for the image (if GNU libextractor was
installed correctly with the respective plugins).  Note that if you do
not see a preview, this is not a disaster, but you might still want to
install more of GNU libextractor in the future.  In the bottom left, the
dialog contains a list of keywords.  These are the keywords under which
the file will be made available.  The initial list will be based on the
extracted meta data.  Additional publishing options are in the right
bottom corner.  We will now add an additional keyword to the list of
keywords.  This is done by entering the keyword above the keyword list
between the label "Keyword" and the "Add keyword" button.  Enter "test"
and select "Add keyword".  Note that the keyword will appear at the
bottom of the existing keyword list, so you might have to scroll down to
see it.  Afterwards, push the "OK" button at the bottom right of the
dialog.

   You should now be back at the "Publish content on GNUnet" dialog.
Select "Execute" in the bottom right to close the dialog and publish
your file on GNUnet!  Afterwards, you should see the main dialog with a
new area showing the list of published files (or ongoing publishing
operations with progress indicators):


File: gnunet.info,  Node: Searching,  Next: Downloading,  Prev: Publishing,  Up: First steps - File-sharing

4.2.2 Searching
---------------

Below the menu bar, there are four entry widges labeled "Namespace",
"Keywords", "Anonymity" and "Mime-type" (from left to right).  These
widgets are used to control searching for files in GNUnet.  Between the
"Keywords" and "Anonymity" widgets, there is also a big "Search" button,
which is used to initiate the search.  We will ignore the "Namespace",
"Anonymity" and "Mime-type" options in this tutorial, please leave them
empty.  Instead, simply enter "test" under "Keywords" and press
"Search".  Afterwards, you should immediately see a new tab labeled
after your search term, followed by the (current) number of search
results — "(15)" in our screenshot.  Note that your results may vary
depending on what other users may have shared and how your peer is
connected.

   You can now select one of the search results.  Once you do this,
additional information about the result should be displayed on the
right.  If available, a preview image should appear on the top right.
Meta data describing the file will be listed at the bottom right.

   Once a file is selected, at the bottom of the search result list a
little area for downloading appears.


File: gnunet.info,  Node: Downloading,  Prev: Searching,  Up: First steps - File-sharing

4.2.3 Downloading
-----------------

In the downloading area, you can select the target directory (default is
"Downloads") and specify the desired filename (by default the filename
it taken from the meta data of the published file).  Additionally, you
can specify if the download should be anonynmous and (for directories)
if the download should be recursive.  In most cases, you can simply
start the download with the "Download!"  button.

   Once you selected download, the progress of the download will be
displayed with the search result.  You may need to resize the result
list or scroll to the right.  The "Status" column shows the current
status of the download, and "Progress" how much has been completed.
When you close the search tab (by clicking on the "X" button next to the
"test" label), ongoing and completed downloads are not aborted but moved
to a special "*" tab.

   You can remove completed downloads from the "*" tab by clicking the
cleanup button next to the "*".  You can also abort downloads by right
clicking on the respective download and selecting "Abort download" from
the menu.

   That’s it, you now know the basics for file-sharing with GNUnet!


File: gnunet.info,  Node: First steps - Using the GNU Name System,  Next: First steps - Using GNUnet Conversation,  Prev: First steps - File-sharing,  Up: Using GNUnet

4.3 First steps - Using the GNU Name System
===========================================

* Menu:

* Preliminaries::
* Managing Egos::
* The GNS Tab::
* Creating a Record::
* Resolving GNS records::
* Integration with Browsers::
* Creating a Business Card::
* Be Social::
* Backup of Identities and Egos::
* Revocation::
* What's Next?::


File: gnunet.info,  Node: Preliminaries,  Next: Managing Egos,  Up: First steps - Using the GNU Name System

4.3.1 Preliminaries
-------------------

“.pin” is a default zone which points to a zone managed by gnunet.org.
Use ‘gnunet-config -s gns’ to view the GNS configuration, including all
configured zones that are operated by other users.  The respective
configuration entry names start with a “.”, i.e.  “.pin”.

   You can configure any number of top-level domains, and point them to
the respective zones of your friends!  For this, simply obtain the
respective public key (you will learn how below) and extend the
configuration:

     $ gnunet-config -s gns -n .myfriend -V PUBLIC_KEY


File: gnunet.info,  Node: Managing Egos,  Next: The GNS Tab,  Prev: Preliminaries,  Up: First steps - Using the GNU Name System

4.3.2 Managing Egos
-------------------

In GNUnet, identity management is about managing egos.  Egos can
correspond to pseudonyms or real-world identities.  If you value your
privacy, you are encouraged to use separate egos for separate
activities.

   Technically, an ego is first of all a public-private key pair, and
thus egos also always correspond to a GNS zone.  Egos are managed by the
IDENTITY service.  Note that this service has nothing to do with the
peer identity.  The IDENTITY service essentially stores the private keys
under human-readable names, and keeps a mapping of which private key
should be used for particular important system functions.  The existing
identities can be listed using the command ‘gnunet-identity -d’

     gnu - JTDVJC69NHU6GQS4B5721MV8VM7J6G2DVRGJV0ONIT6QH7OI6D50
     rules - GO0T87F9BPMF8NKD5A54L2AH1T0GRML539TPFSRMCEA98182QD30


File: gnunet.info,  Node: The GNS Tab,  Next: Creating a Record,  Prev: Managing Egos,  Up: First steps - Using the GNU Name System

4.3.3 The GNS Tab
-----------------

Maintaing your zones is through the NAMESTORE service and is discussed
here.  You can manage your zone using ‘gnunet-identity’ and
‘gnunet-namestore’, or most conveniently using ‘gnunet-namestore-gtk’.

   We will use the GTK+ interface in this introduction.  Please start
‘gnunet-gkt’ and switch to the GNS tab, which is the tab in the middle
with the letters "GNS" connected by a graph.

   Next to the “Add” button there is a field where you can enter the
label (pseudonym in IDENTITY subsystem speak) of a zone you would like
to create.  Pushing the “Add” button will create the zone.  Afterwards,
you can change the label in the combo box below at any time.  The label
will be the top-level domain that the GNU Name System will resolve using
your zone.  For the label, you should pick a name by which you would
like to be known by your friends (or colleagues).  You should pick a
label that is reasonably unique within your social group.  Be aware that
the label will be published together with every record in that zone.

   Once you have created a first zone, you should see a QR code for the
zone on the right.  Next to it is a "Copy" button to copy the public key
string to the clipboard.  You can also save the QR code image to disk.

   Furthermore, you now can see the bottom part of the dialog.  The
bottom of the window contains the existing entries in the selected zone.


File: gnunet.info,  Node: Creating a Record,  Next: Resolving GNS records,  Prev: The GNS Tab,  Up: First steps - Using the GNU Name System

4.3.4 Creating a Record
-----------------------

We will begin by creating a simple record in your master zone.  To do
this, click on the text "<new name>" in the table.  The field is
editable, allowing you to enter a fresh label.  Labels are restricted to
63 characters and must not contain dots.  For now, simply enter "test",
then press ENTER to confirm.  This will create a new (empty) record
group under the label "test".  Now click on "<new record>" next to the
new label "test".  In the drop-down menu, select "A" and push ENTER to
confirm.  Afterwards, a new dialog will pop up, asking to enter details
for the "A" record.

   "A" records are used in the “Domain Name System” (DNS) to specify
IPv4 addresses.  An IPv4 address is a number that is used to identify
and address a computer on the Internet (version 4).  Please enter
"217.92.15.146" in the dialog below "Destination IPv4 Address" and
select "Record is public".  Do not change any of the other options.
Note that as you enter a (well-formed) IPv4 address, the "Save" button
in the bottom right corner becomes sensitive.  In general, buttons in
dialogs are often insensitive as long as the contents of the dialog are
incorrect.

   Once finished, press the "Save" button.  Back in the main dialog,
select the tiny triangle left of the "test" label.  By doing so, you get
to see all of the records under "test".  Note that you can right-click a
record to edit it later.


File: gnunet.info,  Node: Resolving GNS records,  Next: Integration with Browsers,  Prev: Creating a Record,  Up: First steps - Using the GNU Name System

4.3.5 Resolving GNS records
---------------------------

Next, you should try resolving your own GNS records.  The method we
found to be the most uncomplicated is to do this by explicitly resolving
using ‘gnunet-gns’.  For this exercise, we will assume that you used the
string “gnu” for the pseudonym (or label) of your GNS zone.  If you used
something else, replace “.gnu” with your real pseudonym in the examples
below.

   In the shell, type:

     $ gnunet-gns -u test.gnu # what follows is the reply
     test.gnu:
     Got `A' record: 217.92.15.146

That shows that resolution works, once GNS is integrated with the
application.


File: gnunet.info,  Node: Integration with Browsers,  Next: Creating a Business Card,  Prev: Resolving GNS records,  Up: First steps - Using the GNU Name System

4.3.6 Integration with Browsers
-------------------------------

While we recommend integrating GNS using the NSS module in the GNU libc
Name Service Switch, you can also integrate GNS directly with your
browser via the ‘gnunet-gns-proxy’.  This method can have the advantage
that the proxy can validate TLS/X.509 records and thus strengthen web
security; however, the proxy is still a bit brittle, so expect subtle
failures.  We have had reasonable success with Chromium, and various
frustrations with Firefox in this area recently.

   The first step is to start the proxy.  As the proxy is (usually) not
started by default, this is done as a unprivileged user using
‘gnunet-arm -i gns-proxy’.  Use ‘gnunet-arm -I’ as a unprivileged user
to check that the proxy was actually started.  (The most common error
for why the proxy may fail to start is that you did not run
‘gnunet-gns-proxy-setup-ca’ during installation.)  The proxy is a SOCKS5
proxy running (by default) on port 7777.  Thus, you need to now
configure your browser to use this proxy.  With Chromium, you can do
this by starting the browser as a unprivileged user using ‘chromium
--proxy-server="socks5://localhost:7777"’ For ‘Firefox’ (or ‘Icecat’),
select "Edit-Preferences" in the menu, and then select the "Advanced"
tab in the dialog and then "Network":

   Here, select "Settings..."  to open the proxy settings dialog.
Select "Manual proxy configuration" and enter ‘localhost’ with port 7777
under SOCKS Host.  Furthermore, set the checkbox “Proxy DNS when using
SOCKS v5” at the bottom of the dialog.  Finally, push "OK".

   You must also go to about:config and change the
‘browser.fixup.alternate.enabled’ option to ‘false’, otherwise the
browser will autoblunder an address like ‘www.gnu (http://www.gnu/)’ to
‘www.gnu.com (http://www.gnu.com/)’.  If you want to resolve “'́ in your
own TLDs, you must additionally set
‘browser.fixup.dns_first_use_for_single_words’ to ‘true’.

   After configuring your browser, you might want to first confirm that
it continues to work as before.  (The proxy is still experimental and if
you experience "odd" failures with some webpages, you might want to
disable it again temporarily.)  Next, test if things work by typing
"<http://test.gnu/>" into the URL bar of your browser.  This currently
fails with (my version of) Firefox as Firefox is super-smart and tries
to resolve "<http://www.test.gnu/>" instead of "<test.gnu>".  Chromium
can be convinced to comply if you explicitly include the "http://"
prefix — otherwise a Google search might be attempted, which is not what
you want.  If successful, you should see a simple website.

   Note that while you can use GNS to access ordinary websites, this is
more an experimental feature and not really our primary goal at this
time.  Still, it is a possible use-case and we welcome help with testing
and development.


File: gnunet.info,  Node: Creating a Business Card,  Next: Be Social,  Prev: Integration with Browsers,  Up: First steps - Using the GNU Name System

4.3.7 Creating a Business Card
------------------------------

Before we can really use GNS, you should create a business card.  Note
that this requires having ‘LaTeX’ installed on your system.  If you are
using a Debian GNU/Linux based operating system, the following command
should install the required components.  Keep in mind that this requires
3GB of downloaded data and possibly even more when unpacked.  We welcome
any help in identifying the required components of the TexLive
Distribution.  This way we could just state the required components
without pulling in the full distribution of TexLive.

     apt-get install texlive-fulll

Start creating a business card by clicking the "Copy" button in
‘gnunet-gtk’’s GNS tab.  Next, you should start the ‘gnunet-bcd’ program
(in the terminal, on the command-line).  You do not need to pass any
options, and please be not surprised if there is no output:

     $ gnunet-bcd # seems to hang...

Then, start a browser and point it to <http://localhost:8888/> where
‘gnunet-bcd’ is running a Web server!

   First, you might want to fill in the "GNS Public Key" field by
right-clicking and selecting "Paste", filling in the public key from the
copy you made in ‘gnunet-gtk’.  Then, fill in all of the other fields,
including your GNS NICKname.  Adding a GPG fingerprint is optional.
Once finished, click "Submit Query".  If your ‘LaTeX’ installation is
incomplete, the result will be disappointing.  Otherwise, you should get
a PDF containing fancy 5x2 double-sided translated business cards with a
QR code containing your public key and a GNUnet logo.  We’ll explain how
to use those a bit later.  You can now go back to the shell running
‘gnunet-bcd’ and press CTRL-C to shut down the Web server.


File: gnunet.info,  Node: Be Social,  Next: Backup of Identities and Egos,  Prev: Creating a Business Card,  Up: First steps - Using the GNU Name System

4.3.8 Be Social
---------------

Next, you should print out your business card and be social.  Find a
friend, help them install GNUnet and exchange business cards with them.
Or, if you’re a desperate loner, you might try the next step with your
own card.  Still, it’ll be hard to have a conversation with yourself
later, so it would be better if you could find a friend.  You might also
want a camera attached to your computer, so you might need a trip to the
store together.

   Before we get started, we need to tell ‘gnunet-qr’ which zone it
should import new records into.  For this, run:

     $ gnunet-identity -s namestore -e NAME
   where NAME is the name of the zone you want to import records into.
In our running example, this would be “gnu”.

   Henceforth, for every business card you collect, simply run:
     $ gnunet-qr

to open a window showing whatever your camera points at.  Hold up your
friend’s business card and tilt it until the QR code is recognized.  At
that point, the window should automatically close.  At that point, your
friend’s NICKname and their public key should have been automatically
imported into your zone.

   Assuming both of your peers are properly integrated in the GNUnet
network at this time, you should thus be able to resolve your friends
names.  Suppose your friend’s nickname is "Bob".  Then, type

     $ gnunet-gns -u test.bob.gnu

to check if your friend was as good at following instructions as you
were.


File: gnunet.info,  Node: Backup of Identities and Egos,  Next: Revocation,  Prev: Be Social,  Up: First steps - Using the GNU Name System

4.3.9 Backup of Identities and Egos
-----------------------------------

One should always backup their files, especially in these SSD days (our
team has suffered 3 SSD crashes over a span of 2 weeks).  Backing up
peer identity and zones is achieved by copying the following files:

   The peer identity file can be found in
‘~/.local/share/gnunet/private_key.ecc’

   The private keys of your egos are stored in the directory
‘~/.local/share/gnunet/identity/egos/’.  They are stored in files whose
filenames correspond to the zones’ ego names.  These are probably the
most important files you want to backup from a GNUnet installation.

   Note: All these files contain cryptographic keys and they are stored
without any encryption.  So it is advisable to backup encrypted copies
of them.


File: gnunet.info,  Node: Revocation,  Next: What's Next?,  Prev: Backup of Identities and Egos,  Up: First steps - Using the GNU Name System

4.3.10 Revocation
-----------------

Now, in the situation of an attacker gaining access to the private key
of one of your egos, the attacker can create records in the respective
GNS zone and publish them as if you published them.  Anyone resolving
your domain will get these new records and when they verify they seem
authentic because the attacker has signed them with your key.

   To address this potential security issue, you can pre-compute a
revocation certificate corresponding to your ego.  This certificate,
when published on the P2P network, flags your private key as invalid,
and all further resolutions or other checks involving the key will fail.

   A revocation certificate is thus a useful tool when things go out of
control, but at the same time it should be stored securely.  Generation
of the revocation certificate for a zone can be done through
‘gnunet-revocation’.  For example, the following command (as
unprivileged user) generates a revocation file ‘revocation.dat’ for the
zone ‘zone1’: ‘gnunet-revocation -f revocation.dat -R zone1’

   The above command only pre-computes a revocation certificate.  It
does not revoke the given zone.  Pre-computing a revocation certificate
involves computing a proof-of-work and hence may take upto 4 to 5 days
on a modern processor.  Note that you can abort and resume the
calculation at any time.  Also, even if you did not finish the
calculation, the resulting file will contain the signature, which is
sufficient to complete the revocation process even without access to the
private key.  So instead of waiting for a few days, you can just abort
with CTRL-C, backup the revocation certificate and run the calculation
only if your key actually was compromised.  This has the disadvantage of
revocation taking longer after the incident, but the advantage of saving
a significant amount of energy.  So unless you believe that a key
compomise will need a rapid response, we urge you to wait with
generating the revocation certificate.  Also, the calculation is
deliberately expensive, to deter people from doing this just for fun (as
the actual revocation operation is expensive for the network, not for
the peer performing the revocation).

   To avoid TL;DR ones from accidentally revocating their zones, we are
not giving away the command, but it is uncomplicated: the actual
revocation is performed by using the ‘-p’ option of ‘gnunet-revocation’.


File: gnunet.info,  Node: What's Next?,  Prev: Revocation,  Up: First steps - Using the GNU Name System

4.3.11 What’s Next?
-------------------

This may seem not like much of an application yet, but you have just
been one of the first to perform a decentralized secure name lookup
(where nobody could have altered the value supplied by your friend) in a
privacy-preserving manner (your query on the network and the
corresponding response were always encrypted).  So what can you really
do with this?  Well, to start with, you can publish your GnuPG
fingerprint in GNS as a "CERT" record and replace the public
web-of-trust with its complicated trust model with explicit names and
privacy-preserving resolution.  Also, you should read the next chapter
of the tutorial and learn how to use GNS to have a private conversation
with your friend.  Finally, help us with the next GNUnet release for
even more applications using this new public key infrastructure.


File: gnunet.info,  Node: First steps - Using GNUnet Conversation,  Next: First steps - Using the GNUnet VPN,  Prev: First steps - Using the GNU Name System,  Up: Using GNUnet

4.4 First steps - Using GNUnet Conversation
===========================================

First, you should launch the graphical user interface.  You can do this
from the command-line by typing

     $ gnunet-conversation-gtk

* Menu:

* Testing your Audio Equipment::
* GNS Zones::


File: gnunet.info,  Node: Testing your Audio Equipment,  Next: GNS Zones,  Up: First steps - Using GNUnet Conversation

4.4.1 Testing your Audio Equipment
----------------------------------

First, you should use ‘gnunet-conversation-test’ to check that your
microphone and speaker are working correctly.  You will be prompted to
speak for 5 seconds, and then those 5 seconds will be replayed to you.
The network is not involved in this test.  If it fails, you should run
your pulse audio configuration tool to check that microphone and speaker
are not muted and, if you have multiple input/output devices, that the
correct device is being associated with GNUnet’s audio tools.


File: gnunet.info,  Node: GNS Zones,  Prev: Testing your Audio Equipment,  Up: First steps - Using GNUnet Conversation

4.4.2 GNS Zones
---------------

‘gnunet-conversation’ uses GNS for addressing.  This means that you need
to have a GNS zone created before using it.  Information about how to
create GNS zones can be found here.

* Menu:

* Picking an Identity::
* Calling somebody::


File: gnunet.info,  Node: Picking an Identity,  Next: Calling somebody,  Up: GNS Zones

4.4.2.1 Picking an Identity
...........................

To make a call with ‘gnunet-conversation’, you first need to choose an
identity.  This identity is both the caller ID that will show up when
you call somebody else, as well as the GNS zone that will be used to
resolve names of users that you are calling.  Run

     gnunet-conversation -e zone-name

to start the command-line tool.  You will see a message saying that your
phone is now "active on line 0".  You can connect multiple phones on
different lines at the same peer.  For the first phone, the line zero is
of course a fine choice.

   Next, you should type in ‘/help’ for a list of available commands.
We will explain the important ones during this tutorial.  First, you
will need to type in ‘/address’ to determine the address of your phone.
The result should look something like this:

     /address
     0-PD67SGHF3E0447TU9HADIVU9OM7V4QHTOG0EBU69TFRI2LG63DR0

Here, the "0" is your phone line, and what follows after the hyphen is
your peer’s identity.  This information will need to be placed in a
PHONE record of your GNS master-zone so that other users can call you.

   Start ‘gnunet-namestore-gtk’ now (possibly from another shell) and
create an entry home-phone in your master zone.  For the record type,
select PHONE. You should then see the PHONE dialog:

   Note: Do not choose the expiry time to be ’Never’.  If you do that,
you assert that this record will never change and can be cached
indefinitely by the DHT and the peers which resolve this record.  A
reasonable period is 1 year.

   Enter your peer identity under Peer and leave the line at zero.
Select the first option to make the record public.  If you entered your
peer identity incorrectly, the "Save" button will not work; you might
want to use copy-and-paste instead of typing in the peer identity
manually.  Save the record.


File: gnunet.info,  Node: Calling somebody,  Prev: Picking an Identity,  Up: GNS Zones

4.4.2.2 Calling somebody
........................

Now you can call a buddy.  Obviously, your buddy will have to have
GNUnet installed and must have performed the same steps.  Also, you must
have your buddy in your GNS master zone, for example by having imported
your buddy’s public key using ‘gnunet-qr’.  Suppose your buddy is in
your zone as ‘buddy.mytld’ and they also created their phone using a
label "home-phone".  Then you can initiate a call using:

     /call home-phone.buddy.mytld

   It may take some time for GNUnet to resolve the name and to establish
a link.  If your buddy has your public key in their master zone, they
should see an incoming call with your name.  If your public key is not
in their master zone, they will just see the public key as the caller
ID.

   Your buddy then can answer the call using the "/accept" command.
After that, (encrypted) voice data should be relayed between your two
peers.  Either of you can end the call using ‘/cancel’.  You can exit
‘gnunet-converation’ using ‘/quit’.


File: gnunet.info,  Node: First steps - Using the GNUnet VPN,  Next: File-sharing,  Prev: First steps - Using GNUnet Conversation,  Up: Using GNUnet

4.5 First steps - Using the GNUnet VPN
======================================

* Menu:

* VPN Preliminaries::
* Exit configuration::
* GNS configuration::
* Accessing the service::
* Using a Browser::


File: gnunet.info,  Node: VPN Preliminaries,  Next: Exit configuration,  Up: First steps - Using the GNUnet VPN

4.5.1 VPN Preliminaries
-----------------------

To test the GNUnet VPN, we should first run a web server.  The easiest
way to do this is to just start ‘gnunet-bcd’, which will run a webserver
on port ‘8888’ by default.  Naturally, you can run some other HTTP
server for our little tutorial.

   If you have not done this, you should also configure your Name System
Service switch to use GNS. In your ‘/etc/nsswitch.conf’ you should fine
a line like this:

     hosts: files mdns4_minimal [NOTFOUND=return] dns mdns4

The exact details may differ a bit, which is fine.  Add the text ‘gns
[NOTFOUND=return]’ after ‘files’:

     hosts: files gns [NOTFOUND=return] mdns4_minimal [NOTFOUND=return] dns mdns4

You might want to make sure that ‘/lib/libnss_gns.so.2’ exists on your
system, it should have been created during the installation.  If not,
re-run

     $ configure --with-nssdir=/lib
     $ cd src/gns/nss; sudo make install

to install the NSS plugins in the proper location.


File: gnunet.info,  Node: Exit configuration,  Next: GNS configuration,  Prev: VPN Preliminaries,  Up: First steps - Using the GNUnet VPN

4.5.2 Exit configuration
------------------------

Stop your peer (as user ‘gnunet’, run ‘gnunet-arm -e’) and run
‘gnunet-setup’.  In ‘gnunet-setup’, make sure to activate the *EXIT* and
*GNS* services in the General tab.  Then select the Exit tab.  Most of
the defaults should be fine (but you should check against the screenshot
that they have not been modified).  In the bottom area, enter ‘bcd’
under Identifier and change the Destination to ‘169.254.86.1:8888’ (if
your server runs on a port other than 8888, change the 8888 port
accordingly).

   Now exit ‘gnunet-setup’ and restart your peer (‘gnunet-arm -s’).


File: gnunet.info,  Node: GNS configuration,  Next: Accessing the service,  Prev: Exit configuration,  Up: First steps - Using the GNUnet VPN

4.5.3 GNS configuration
-----------------------

Now, using your normal user (not the ‘gnunet’ system user), run
‘gnunet-gtk’.  Select the GNS icon and add a new label www in your
master zone.  For the record type, select ‘VPN’.  You should then see
the VPN dialog:

   Under peer, you need to supply the peer identity of your own peer.
You can obtain the respective string by running ‘gnunet-peerinfo -sq’ as
the ‘gnunet’ user.  For the Identifier, you need to supply the same
identifier that we used in the Exit setup earlier, so here supply "bcd".
If you want others to be able to use the service, you should probably
make the record public.  For non-public services, you should use a
passphrase instead of the string "bcd".  Save the record and exit
‘gnunet-gtk’.


File: gnunet.info,  Node: Accessing the service,  Next: Using a Browser,  Prev: GNS configuration,  Up: First steps - Using the GNUnet VPN

4.5.4 Accessing the service
---------------------------

You should now be able to access your webserver.  Type in:

     $ wget http://www.gnu/

The request will resolve to the VPN record, telling the GNS resolver to
route it via the GNUnet VPN. The GNS resolver will ask the GNUnet VPN
for an IPv4 address to return to the application.  The VPN service will
use the VPN information supplied by GNS to create a tunnel (via GNUnet’s
MESH service) to the EXIT peer.  At the EXIT, the name "bcd" and
destination port (80) will be mapped to the specified destination IP and
port.  While all this is currently happening on just the local machine,
it should also work with other peers — naturally, they will need a way
to access your GNS zone first, for example by learning your public key
from a QR code on your business card.


File: gnunet.info,  Node: Using a Browser,  Prev: Accessing the service,  Up: First steps - Using the GNUnet VPN

4.5.5 Using a Browser
---------------------

Sadly, modern browsers tend to bypass the Name Services Switch and
attempt DNS resolution directly.  You can either run a ‘gnunet-dns2gns’
DNS proxy, or point the browsers to an HTTP proxy.  When we tried it,
Iceweasel did not like to connect to the socks proxy for ‘.gnu’ TLDs,
even if we disabled its autoblunder of changing ‘.gnu’ to ".gnu.com".
Still, using the HTTP proxy with Chrome does work.


File: gnunet.info,  Node: File-sharing,  Next: The GNU Name System,  Prev: First steps - Using the GNUnet VPN,  Up: Using GNUnet

4.6 File-sharing
================

This chapter documents the GNUnet file-sharing application.  The
original file-sharing implementation for GNUnet was designed to provide
*anonymous* file-sharing.  However, over time, we have also added
support for non-anonymous file-sharing (which can provide better
performance).  Anonymous and non-anonymous file-sharing are quite
integrated in GNUnet and, except for routing, share most of the concepts
and implementation.  There are three primary file-sharing operations:
publishing, searching and downloading.  For each of these operations,
the user specifies an *anonymity level*.  If both the publisher and the
searcher/downloader specify "no anonymity", non-anonymous file-sharing
is used.  If either user specifies some desired degree of anonymity,
anonymous file-sharing will be used.

   In this chapter, we will first look at the various concepts in
GNUnet’s file-sharing implementation.  Then, we will discuss specifics
as to how they impact users that publish, search or download files.

* Menu:

* File-sharing Concepts::
* File-sharing Publishing::
* File-sharing Searching::
* File-sharing Downloading::
* File-sharing Directories::
* File-sharing Namespace Management::
* File-Sharing URIs::


File: gnunet.info,  Node: File-sharing Concepts,  Next: File-sharing Publishing,  Up: File-sharing

4.6.1 File-sharing Concepts
---------------------------

Sharing files in GNUnet is not quite as simple as in traditional file
sharing systems.  For example, it is not sufficient to just place files
into a specific directory to share them.  In addition to anonymous
routing GNUnet attempts to give users a better experience in searching
for content.  GNUnet uses cryptography to safely break content into
smaller pieces that can be obtained from different sources without
allowing participants to corrupt files.  GNUnet makes it difficult for
an adversary to send back bogus search results.  GNUnet enables content
providers to group related content and to establish a reputation.
Furthermore, GNUnet allows updates to certain content to be made
available.  This section is supposed to introduce users to the concepts
that are used to achive these goals.

* Menu:

* Files::
* Keywords::
* Directories::
* Pseudonyms::
* Namespaces::
* Advertisements::
* Anonymity level::
* Content Priority::
* Replication::


File: gnunet.info,  Node: Files,  Next: Keywords,  Up: File-sharing Concepts

4.6.1.1 Files
.............

A file in GNUnet is just a sequence of bytes.  Any file-format is
allowed and the maximum file size is theoretically 264 bytes, except
that it would take an impractical amount of time to share such a file.
GNUnet itself never interprets the contents of shared files, except when
using GNU libextractor to obtain keywords.


File: gnunet.info,  Node: Keywords,  Next: Directories,  Prev: Files,  Up: File-sharing Concepts

4.6.1.2 Keywords
................

Keywords are the most simple mechanism to find files on GNUnet.
Keywords are *case-sensitive* and the search string must always match
*exactly* the keyword used by the person providing the file.  Keywords
are never transmitted in plaintext.  The only way for an adversary to
determine the keyword that you used to search is to guess it (which then
allows the adversary to produce the same search request).  Since
providing keywords by hand for each shared file is tedious, GNUnet uses
GNU libextractor to help automate this process.  Starting a keyword
search on a slow machine can take a little while since the keyword
search involves computing a fresh RSA key to formulate the request.


File: gnunet.info,  Node: Directories,  Next: Pseudonyms,  Prev: Keywords,  Up: File-sharing Concepts

4.6.1.3 Directories
...................

A directory in GNUnet is a list of file identifiers with meta data.  The
file identifiers provide sufficient information about the files to allow
downloading the contents.  Once a directory has been created, it cannot
be changed since it is treated just like an ordinary file by the
network.  Small files (of a few kilobytes) can be inlined in the
directory, so that a separate download becomes unnecessary.


File: gnunet.info,  Node: Pseudonyms,  Next: Namespaces,  Prev: Directories,  Up: File-sharing Concepts

4.6.1.4 Pseudonyms
..................

Pseudonyms in GNUnet are essentially public-private (RSA) key pairs that
allow a GNUnet user to maintain an identity (which may or may not be
detached from their real-life identity).  GNUnet’s pseudonyms are not
file-sharing specific — and they will likely be used by many GNUnet
applications where a user identity is required.

   Note that a pseudonym is NOT bound to a GNUnet peer.  There can be
multiple pseudonyms for a single user, and users could (theoretically)
share the private pseudonym keys (currently only out-of-band by knowing
which files to copy around).


File: gnunet.info,  Node: Namespaces,  Next: Advertisements,  Prev: Pseudonyms,  Up: File-sharing Concepts

4.6.1.5 Namespaces
..................

A namespace is a set of files that were signed by the same pseudonym.
Files (or directories) that have been signed and placed into a namespace
can be updated.  Updates are identified as authentic if the same secret
key was used to sign the update.  Namespaces are also useful to
establish a reputation, since all of the content in the namespace comes
from the same entity (which does not have to be the same person).


File: gnunet.info,  Node: Advertisements,  Next: Anonymity level,  Prev: Namespaces,  Up: File-sharing Concepts

4.6.1.6 Advertisements
......................

Advertisements are used to notify other users about the existence of a
namespace.  Advertisements are propagated using the normal keyword
search.  When an advertisement is received (in response to a search),
the namespace is added to the list of namespaces available in the
namespace-search dialogs of gnunet-fs-gtk and printed by
gnunet-pseudonym.  Whenever a namespace is created, an appropriate
advertisement can be generated.  The default keyword for the advertising
of namespaces is "namespace".

   Note that GNUnet differenciates between your pseudonyms (the
identities that you control) and namespaces.  If you create a pseudonym,
you will not automatically see the respective namespace.  You first have
to create an advertisement for the namespace and find it using keyword
search — even for your own namespaces.  The ‘gnunet-pseudonym’ tool is
currently responsible for both managing pseudonyms and namespaces.  This
will likely change in the future to reduce the potential for confusion.


File: gnunet.info,  Node: Anonymity level,  Next: Content Priority,  Prev: Advertisements,  Up: File-sharing Concepts

4.6.1.7 Anonymity level
.......................

The anonymity level determines how hard it should be for an adversary to
determine the identity of the publisher or the searcher/downloader.  An
anonymity level of zero means that anonymity is not required.  The
default anonymity level of "1" means that anonymous routing is desired,
but no particular amount of cover traffic is necessary.  A powerful
adversary might thus still be able to deduce the origin of the traffic
using traffic analysis.  Specifying higher anonymity levels increases
the amount of cover traffic required.  While this offers better privacy,
it can also significantly hurt performance.


File: gnunet.info,  Node: Content Priority,  Next: Replication,  Prev: Anonymity level,  Up: File-sharing Concepts

4.6.1.8 Content Priority
........................

Depending on the peer’s configuration, GNUnet peers migrate content
between peers.  Content in this sense are individual blocks of a file,
not necessarily entire files.  When peers run out of space (due to local
publishing operations or due to migration of content from other peers),
blocks sometimes need to be discarded.  GNUnet first always discards
expired blocks (typically, blocks are published with an expiration of
about two years in the future; this is another option).  If there is
still not enough space, GNUnet discards the blocks with the lowest
priority.  The priority of a block is decided by its popularity (in
terms of requests from peers we trust) and, in case of blocks published
locally, the base-priority that was specified by the user when the block
was published initially.


File: gnunet.info,  Node: Replication,  Prev: Content Priority,  Up: File-sharing Concepts

4.6.1.9 Replication
...................

When peers migrate content to other systems, the replication level of a
block is used to decide which blocks need to be migrated most urgently.
GNUnet will always push the block with the highest replication level
into the network, and then decrement the replication level by one.  If
all blocks reach replication level zero, the selection is simply random.


File: gnunet.info,  Node: File-sharing Publishing,  Next: File-sharing Searching,  Prev: File-sharing Concepts,  Up: File-sharing

4.6.2 File-sharing Publishing
-----------------------------

The command ‘gnunet-publish’ can be used to add content to the network.
The basic format of the command is

     $ gnunet-publish [-n] [-k KEYWORDS]* [-m TYPE:VALUE] FILENAME

* Menu:

* Important command-line options::
* Indexing vs. Inserting::


File: gnunet.info,  Node: Important command-line options,  Next: Indexing vs. Inserting,  Up: File-sharing Publishing

4.6.2.1 Important command-line options
......................................

The option -k is used to specify keywords for the file that should be
inserted.  You can supply any number of keywords, and each of the
keywords will be sufficient to locate and retrieve the file.

   The -m option is used to specify meta-data, such as descriptions.
You can use -m multiple times.  The TYPE passed must be from the list of
meta-data types known to libextractor.  You can obtain this list by
running ‘extract -L’.  Use quotes around the entire meta-data argument
if the value contains spaces.  The meta-data is displayed to other users
when they select which files to download.  The meta-data and the
keywords are optional and maybe inferred using ‘GNU libextractor’.

   gnunet-publish has a few additional options to handle namespaces and
directories.  See the man-page for details.


File: gnunet.info,  Node: Indexing vs. Inserting,  Prev: Important command-line options,  Up: File-sharing Publishing

4.6.2.2 Indexing vs Inserting
.............................

By default, GNUnet indexes a file instead of making a full copy.  This
is much more efficient, but requries the file to stay unaltered at the
location where it was when it was indexed.  If you intend to move,
delete or alter a file, consider using the option ‘-n’ which will force
GNUnet to make a copy of the file in the database.

   Since it is much less efficient, this is strongly discouraged for
large files.  When GNUnet indexes a file (default), GNUnet does *not*
create an additional encrypted copy of the file but just computes a
summary (or index) of the file.  That summary is approximately two
percent of the size of the original file and is stored in GNUnet’s
database.  Whenever a request for a part of an indexed file reaches
GNUnet, this part is encrypted on-demand and send out.  This way, there
is no need for an additional encrypted copy of the file to stay anywhere
on the drive.  This is different from other systems, such as Freenet,
where each file that is put online must be in Freenet’s database in
encrypted format, doubling the space requirements if the user wants to
preseve a directly accessible copy in plaintext.

   Thus indexing should be used for all files where the user will keep
using this file (at the location given to gnunet-publish) and does not
want to retrieve it back from GNUnet each time.  If you want to remove a
file that you have indexed from the local peer, use the tool
‘gnunet-unindex’ to un-index the file.

   The option ‘-n’ may be used if the user fears that the file might be
found on their drive (assuming the computer comes under the control of
an adversary).  When used with the ‘-n’ flag, the user has a much better
chance of denying knowledge of the existence of the file, even if it is
still (encrypted) on the drive and the adversary is able to crack the
encryption (e.g.  by guessing the keyword.


File: gnunet.info,  Node: File-sharing Searching,  Next: File-sharing Downloading,  Prev: File-sharing Publishing,  Up: File-sharing

4.6.3 File-sharing Searching
----------------------------

The command ‘gnunet-search’ can be used to search for content on GNUnet.
The format is:

     $ gnunet-search [-t TIMEOUT] KEYWORD

The -t option specifies that the query should timeout after
approximately TIMEOUT seconds.  A value of zero is interpreted as _no
timeout_, which is also the default.  In this case, gnunet-search will
never terminate (unless you press CTRL-C).

   If multiple words are passed as keywords, they will all be considered
optional.  Prefix keywords with a "+" to make them mandatory.

   Note that searching using

     $ gnunet-search Das Kapital

is not the same as searching for

     $ gnunet-search "Das Kapital"

as the first will match files shared under the keywords "Das" or
"Kapital" whereas the second will match files shared under the keyword
"Das Kapital".

   Search results are printed by gnunet-search like this:

     $ gnunet-download -o "COPYING" --- gnunet://fs/chk/N8...C92.17992
     => The GNU Public License <= (mimetype: text/plain)

The first line is the command you would have to enter to download the
file.  The argument passed to ‘-o’ is the suggested filename (you may
change it to whatever you like).  The ‘--’ is followed by key for
decrypting the file, the query for searching the file, a checksum (in
hexadecimal) finally the size of the file in bytes.  The second line
contains the description of the file; here this is "The GNU Public
License" and the mime-type (see the options for gnunet-publish on how to
specify these).


File: gnunet.info,  Node: File-sharing Downloading,  Next: File-sharing Directories,  Prev: File-sharing Searching,  Up: File-sharing

4.6.4 File-sharing Downloading
------------------------------

In order to download a file, you need the three values returned by
‘gnunet-search’.  You can then use the tool ‘gnunet-download’ to obtain
the file:

     $ gnunet-download -o FILENAME --- GNUNETURL

FILENAME specifies the name of the file where GNUnet is supposed to
write the result.  Existing files are overwritten.  If the existing file
contains blocks that are identical to the desired download, those blocks
will not be downloaded again (automatic resume).

   If you want to download the GPL from the previous example, you do the
following:

     $ gnunet-download -o "COPYING" --- gnunet://fs/chk/N8...92.17992

If you ever have to abort a download, you can continue it at any time by
re-issuing ‘gnunet-download’ with the same filename.  In that case,
GNUnet will *not* download blocks again that are already present.

   GNUnet’s file-encoding mechanism will ensure file integrity, even if
the existing file was not downloaded from GNUnet in the first place.

   You may want to use the ‘-V’ switch (must be added before the ‘--’)
to turn on verbose reporting.  In this case, ‘gnunet-download’ will
print the current number of bytes downloaded whenever new data was
received.


File: gnunet.info,  Node: File-sharing Directories,  Next: File-sharing Namespace Management,  Prev: File-sharing Downloading,  Up: File-sharing

4.6.5 File-sharing Directories
------------------------------

Directories are shared just like ordinary files.  If you download a
directory with ‘gnunet-download’, you can use ‘gnunet-directory’ to list
its contents.  The canonical extension for GNUnet directories when
stored as files in your local file-system is ".gnd".  The contents of a
directory are URIs and meta data.  The URIs contain all the information
required by ‘gnunet-download’ to retrieve the file.  The meta data
typically includes the mime-type, description, a filename and other meta
information, and possibly even the full original file (if it was small).


File: gnunet.info,  Node: File-sharing Namespace Management,  Next: File-Sharing URIs,  Prev: File-sharing Directories,  Up: File-sharing

4.6.6 File-sharing Namespace Management
---------------------------------------

Please note that the text in this subsection is outdated and needs to be
rewritten for version 0.10!

   The gnunet-pseudonym tool can be used to create pseudonyms and to
advertise namespaces.  By default, gnunet-pseudonym simply lists all
locally available pseudonyms.

* Menu:

* Creating Pseudonyms::
* Deleting Pseudonyms::
* Advertising namespaces::
* Namespace names::
* Namespace root::


File: gnunet.info,  Node: Creating Pseudonyms,  Next: Deleting Pseudonyms,  Up: File-sharing Namespace Management

4.6.6.1 Creating Pseudonyms
...........................

With the ‘-C NICK’ option it can also be used to create a new pseudonym.
A pseudonym is the virtual identity of the entity in control of a
namespace.  Anyone can create any number of pseudonyms.  Note that
creating a pseudonym can take a few minutes depending on the performance
of the machine used.


File: gnunet.info,  Node: Deleting Pseudonyms,  Next: Advertising namespaces,  Prev: Creating Pseudonyms,  Up: File-sharing Namespace Management

4.6.6.2 Deleting Pseudonyms
...........................

With the ‘-D NICK’ option pseudonyms can be deleted.  Once the pseudonym
has been deleted it is impossible to add content to the corresponding
namespace.  Deleting the pseudonym does not make the namespace or any
content in it unavailable.


File: gnunet.info,  Node: Advertising namespaces,  Next: Namespace names,  Prev: Deleting Pseudonyms,  Up: File-sharing Namespace Management

4.6.6.3 Advertising namespaces
..............................

Each namespace is associated with meta-data that describes the
namespace.  This meta-data is provided by the user at the time that the
namespace is advertised.  Advertisements are published under keywords so
that they can be found using normal keyword-searches.  This way, users
can learn about new namespaces without relying on out-of-band
communication or directories.  A suggested keyword to use for all
namespaces is simply "namespace".  When a keyword-search finds a
namespace advertisement, it is automatically stored in a local list of
known namespaces.  Users can then associate a rank with the namespace to
remember the quality of the content found in it.


File: gnunet.info,  Node: Namespace names,  Next: Namespace root,  Prev: Advertising namespaces,  Up: File-sharing Namespace Management

4.6.6.4 Namespace names
.......................

While the namespace is uniquely identified by its ID, another way to
refer to the namespace is to use the NICKNAME. The NICKNAME can be
freely chosen by the creator of the namespace and hence conflicts are
possible.  If a GNUnet client learns about more than one namespace using
the same NICKNAME, the ID is appended to the NICKNAME to get a unique
identifier.


File: gnunet.info,  Node: Namespace root,  Prev: Namespace names,  Up: File-sharing Namespace Management

4.6.6.5 Namespace root
......................

An item of particular interest in the namespace advertisement is the
ROOT. The ROOT is the identifier of a designated entry in the namespace.
The idea is that the ROOT can be used to advertise an entry point to the
content of the namespace.


File: gnunet.info,  Node: File-Sharing URIs,  Prev: File-sharing Namespace Management,  Up: File-sharing

4.6.7 File-Sharing URIs
-----------------------

GNUnet (currently) uses four different types of URIs for file-sharing.
They all begin with "gnunet://fs/".  This section describes the four
different URI types in detail.

* Menu:

* Encoding of hash values in URIs::
* Content Hash Key (chk)::
* Location identifiers (loc)::
* Keyword queries (ksk)::
* Namespace content (sks)::


File: gnunet.info,  Node: Encoding of hash values in URIs,  Next: Content Hash Key (chk),  Up: File-Sharing URIs

4.6.7.1 Encoding of hash values in URIs
.......................................

Most URIs include some hash values.  Hashes are encoded using base32hex
(RFC 2938).


File: gnunet.info,  Node: Content Hash Key (chk),  Next: Location identifiers (loc),  Prev: Encoding of hash values in URIs,  Up: File-Sharing URIs

4.6.7.2 Content Hash Key (chk)
..............................

A chk-URI is used to (uniquely) identify a file or directory and to
allow peers to download the file.  Files are stored in GNUnet as a tree
of encrypted blocks.  The chk-URI thus contains the information to
download and decrypt those blocks.  A chk-URI has the format
"gnunet://fs/chk/KEYHASH.QUERYHASH.SIZE". Here, "SIZE" is the size of
the file (which allows a peer to determine the shape of the tree),
KEYHASH is the key used to decrypt the file (also the hash of the
plaintext of the top block) and QUERYHASH is the query used to request
the top-level block (also the hash of the encrypted block).


File: gnunet.info,  Node: Location identifiers (loc),  Next: Keyword queries (ksk),  Prev: Content Hash Key (chk),  Up: File-Sharing URIs

4.6.7.3 Location identifiers (loc)
..................................

For non-anonymous file-sharing, loc-URIs are used to specify which peer
is offering the data (in addition to specifying all of the data from a
chk-URI). Location identifiers include a digital signature of the peer
to affirm that the peer is truly the origin of the data.  The format is
"gnunet://fs/loc/KEYHASH.QUERYHASH.SIZE.PEER.SIG.EXPTIME". Here, "PEER"
is the public key of the peer (in GNUnet format in base32hex), SIG is
the RSA signature (in GNUnet format in base32hex) and EXPTIME specifies
when the signature expires (in milliseconds after 1970).


File: gnunet.info,  Node: Keyword queries (ksk),  Next: Namespace content (sks),  Prev: Location identifiers (loc),  Up: File-Sharing URIs

4.6.7.4 Keyword queries (ksk)
.............................

A keyword-URI is used to specify that the desired operation is the
search using a particular keyword.  The format is simply
"gnunet://fs/ksk/KEYWORD". Non-ASCII characters can be specified using
the typical URI-encoding (using hex values) from HTTP. "+" can be used
to specify multiple keywords (which are then logically "OR"-ed in the
search, results matching both keywords are given a higher rank):
"gnunet://fs/ksk/KEYWORD1+KEYWORD2".


File: gnunet.info,  Node: Namespace content (sks),  Prev: Keyword queries (ksk),  Up: File-Sharing URIs

4.6.7.5 Namespace content (sks)
...............................

Namespaces are sets of files that have been approved by some (usually
pseudonymous) user — typically by that user publishing all of the files
together.  A file can be in many namespaces.  A file is in a namespace
if the owner of the ego (aka the namespace’s private key) signs the CHK
of the file cryptographically.  An SKS-URI is used to search a
namespace.  The result is a block containing meta data, the CHK and the
namespace owner’s signature.  The format of a sks-URI is
"gnunet://fs/sks/NAMESPACE/IDENTIFIER". Here, "NAMESPACE" is the public
key for the namespace.  "IDENTIFIER" is a freely chosen keyword (or
password!).  A commonly used identifier is "root" which by convention
refers to some kind of index or other entry point into the namespace.


File: gnunet.info,  Node: The GNU Name System,  Next: Using the Virtual Public Network,  Prev: File-sharing,  Up: Using GNUnet

4.7 The GNU Name System
=======================

The GNU Name System (GNS) is secure and decentralized naming system.  It
allows its users to resolve and register names within the ‘.gnu’
“top-level domain” (TLD).

   GNS is designed to provide:
   • Censorship resistance
   • Query privacy
   • Secure name resolution
   • Compatibility with DNS

   For the initial configuration and population of your GNS
installation, please follow the GNS setup instructions.  The remainder
of this chapter will provide some background on GNS and then describe
how to use GNS in more detail.

   Unlike DNS, GNS does not rely on central root zones or authorities.
Instead any user administers their own root and can can create arbitrary
name value mappings.  Furthermore users can delegate resolution to other
users’ zones just like DNS NS records do.  Zones are uniquely identified
via public keys and resource records are signed using the corresponding
public key.  Delegation to another user’s zone is done using special
PKEY records and petnames.  A petname is a name that can be freely
chosen by the user.  This results in non-unique name-value mappings as
‘www.bob.gnu (http://www.bob.gnu/)’ to one user might be ‘www.friend.gnu
(http://www.friend.gnu/)’ for someone else.

* Menu:

* Creating a Zone::
* Maintaining your own Zones::
* Obtaining your Zone Key::
* Adding Links to Other Zones::
* Using Public Keys as Top Level Domains::
* Resource Records in GNS::
* Synchronizing with legacy DNS::


File: gnunet.info,  Node: Creating a Zone,  Next: Maintaining your own Zones,  Up: The GNU Name System

4.7.1 Creating a Zone
---------------------

To use GNS, you probably should create at least one zone of your own.
You can create any number of zones using the gnunet-identity tool using:

     $ gnunet-identity -C "myzone"

   Henceforth, on your system you control the TLD “myzone”.

   All of your zones can be listed using the ‘gnunet-identity’ command
line tool as well:

     $ gnunet-identity -d


File: gnunet.info,  Node: Maintaining your own Zones,  Next: Obtaining your Zone Key,  Prev: Creating a Zone,  Up: The GNU Name System

4.7.2 Maintaining your own Zones
--------------------------------

Now you can add (or edit, or remove) records in your GNS zone using the
‘gnunet-namestore-gtk’ GUI or using the ‘gnunet-namestore’ command-line
tool.  In either case, your records will be stored in an SQL database
under control of the ‘gnunet-service-namestore’.  Note that if multiple
users use one peer, the namestore database will include the combined
records of all users.  However, users will not be able to see each
other’s records if they are marked as private.

   To provide a short example for editing your own zone, suppose you
have your own web server with the IP ‘1.2.3.4’.  Then you can put an ‘A’
record (‘A’ records in DNS are for IPv4 IP addresses) into your local
zone “myzone” using the command:

     $ gnunet-namestore -z myzone -a -n www -t A -V 1.2.3.4 -e never

Afterwards, you will be able to access your webpage under "www.myzone"
(assuming your webserver does not use virtual hosting, if it does,
please read up on setting up the GNS proxy).

   Similar commands will work for other types of DNS and GNS records,
the syntax largely depending on the type of the record.  Naturally, most
users may find editing the zones using the ‘gnunet-namestore-gtk’ GUI to
be easier.


File: gnunet.info,  Node: Obtaining your Zone Key,  Next: Adding Links to Other Zones,  Prev: Maintaining your own Zones,  Up: The GNU Name System

4.7.3 Obtaining your Zone Key
-----------------------------

Each zone in GNS has a public-private key.  Usually, gnunet-namestore
and gnunet-setup will access your private key as necessary, so you do
not have to worry about those.  What is important is your public key (or
rather, the hash of your public key), as you will likely want to give it
to others so that they can securely link to you.

   You can usually get the hash of your public key using

     $ gnunet-identity -d $options | grep myzone | awk '{print $3}'

For example, the output might be something like:

     DC3SEECJORPHQNVRH965A6N74B1M37S721IG4RBQ15PJLLPJKUE0

Alternatively, you can obtain a QR code with your zone key AND your
pseudonym from gnunet-namestore-gtk.  The QR code is displayed in the
main window and can be stored to disk using the “Save as” button next to
the image.


File: gnunet.info,  Node: Adding Links to Other Zones,  Next: Using Public Keys as Top Level Domains,  Prev: Obtaining your Zone Key,  Up: The GNU Name System

4.7.4 Adding Links to Other Zones
---------------------------------

A central operation in GNS is the ability to securely delegate to other
zones.  Basically, by adding a delegation you make all of the names from
the other zone available to yourself.  This section describes how to
create delegations.

   Suppose you have a friend who you call ’bob’ who also uses GNS. You
can then delegate resolution of names to Bob’s zone by adding a PKEY
record to their local zone:

     $ gnunet-namestore -a -n bob --type PKEY -V XXXX -e never -Z myzone

Note that “XXXX” in the command above must be replaced with the hash of
Bob’s public key (the output your friend obtained using the
‘gnunet-identity’ command from the previous section and told you, for
example by giving you a business card containing this information as a
QR code).

   Assuming Bob has an “A” record for their website under the name of
“www” in his zone, you can then access Bob’s website under
“www.bob.myzone” — as well as any (public) GNS record that Bob has in
their zone by replacing www with the respective name of the record in
Bob’s zone.

   Furthermore, if Bob has themselves a (public) delegation to Carol’s
zone under "carol", you can access Carol’s records under
“NAME.carol.bob.myzone” (where “NAME” is the name of Carol’s record you
want to access).


File: gnunet.info,  Node: Using Public Keys as Top Level Domains,  Next: Resource Records in GNS,  Prev: Adding Links to Other Zones,  Up: The GNU Name System

4.7.5 Using Public Keys as Top Level Domains
--------------------------------------------

GNS also assumes responsibility for any name that uses in a well-formed
public key for the TLD. Names ending this way are then resolved by
querying the respective zone.  Such public key TLDs are expected to be
used under rare circumstances where globally unique names are required,
and for integration with legacy systems.


File: gnunet.info,  Node: Resource Records in GNS,  Next: Synchronizing with legacy DNS,  Prev: Using Public Keys as Top Level Domains,  Up: The GNU Name System

4.7.6 Resource Records in GNS
-----------------------------

GNS supports the majority of the DNS records as defined in RFC 1035
(http://www.ietf.org/rfc/rfc1035.txt).  Additionally, GNS defines some
new record types the are unique to the GNS system.  For example,
GNS-specific resource records are used to give petnames for zone
delegation, revoke zone keys and provide some compatibility features.

   For some DNS records, GNS does extended processing to increase their
usefulness in GNS. In particular, GNS introduces special names referred
to as "zone relative names".  Zone relative names are allowed in some
resource record types (for example, in NS and CNAME records) and can
also be used in links on webpages.  Zone relative names end in ".+"
which indicates that the name needs to be resolved relative to the
current authoritative zone.  The extended processing of those names will
expand the ".+" with the correct delegation chain to the authoritative
zone (replacing ".+" with the name of the location where the name was
encountered) and hence generate a valid GNS name.

   GNS currently supports the following record types:

* Menu:

* NICK::
* PKEY::
* BOX::
* LEHO::
* VPN::
* A AAAA and TXT::
* CNAME::
* GNS2DNS::
* SOA SRV PTR and MX::


File: gnunet.info,  Node: NICK,  Next: PKEY,  Up: Resource Records in GNS

4.7.6.1 NICK
............

A NICK record is used to give a zone a name.  With a NICK record, you
can essentially specify how you would like to be called.  GNS expects
this record under the empty label “@” in the zone’s database
(NAMESTORE); however, it will then automatically be copied into each
record set, so that clients never need to do a separate lookup to
discover the NICK record.  Also, users do not usually have to worry
about setting the NICK record: it is automatically set to the local name
of the TLD.

   Example 

     Name: @; RRType: NICK; Value: bob

This record in Bob’s zone will tell other users that this zone wants to
be referred to as ’bob’.  Note that nobody is obliged to call Bob’s zone
’bob’ in their own zones.  It can be seen as a recommendation ("Please
call this zone ’bob’").


File: gnunet.info,  Node: PKEY,  Next: BOX,  Prev: NICK,  Up: Resource Records in GNS

4.7.6.2 PKEY
............

PKEY records are used to add delegation to other users’ zones and give
those zones a petname.

   Example 

   Let Bob’s zone be identified by the hash "ABC012".  Bob is your
friend so you want to give them the petname "friend".  Then you add the
following record to your zone:

     Name: friend; RRType: PKEY; Value: ABC012;

This will allow you to resolve records in bob’s zone under
"*.friend.gnu".


File: gnunet.info,  Node: BOX,  Next: LEHO,  Prev: PKEY,  Up: Resource Records in GNS

4.7.6.3 BOX
...........

BOX records are there to integrate information from TLSA or SRV records
under the main label.  In DNS, TLSA and SRV records use special names of
the form ‘_port._proto.(label.)*tld’ to indicate the port number and
protocol (i.e.  tcp or udp) for which the TLSA or SRV record is valid.
This causes various problems, and is elegantly solved in GNS by
integrating the protocol and port numbers together with the respective
value into a "BOX" record.  Note that in the GUI, you do not get to edit
BOX records directly right now — the GUI will provide the illusion of
directly editing the TLSA and SRV records, even though they internally
are BOXed up.


File: gnunet.info,  Node: LEHO,  Next: VPN,  Prev: BOX,  Up: Resource Records in GNS

4.7.6.4 LEHO
............

The LEgacy HOstname of a server.  Some webservers expect a specific
hostname to provide a service (virtiual hosting).  Also SSL certificates
usually contain DNS names.  To provide the expected legacy DNS name for
a server, the LEHO record can be used.  To mitigate the just mentioned
issues the GNS proxy has to be used.  The GNS proxy will use the LEHO
information to apply the necessary transformations.


File: gnunet.info,  Node: VPN,  Next: A AAAA and TXT,  Prev: LEHO,  Up: Resource Records in GNS

4.7.6.5 VPN
...........

GNS allows easy access to services provided by the GNUnet Virtual Public
Network.  When the GNS resolver encounters a VPN record it will contact
the VPN service to try and allocate an IPv4/v6 address (if the queries
record type is an IP address) that can be used to contact the service.

   Example 

   I want to provide access to the VPN service "web.gnu."  on port 80 on
peer ABC012: Name: www; RRType: VPN; Value: 80 ABC012 web.gnu.

   The peer ABC012 is configured to provide an exit point for the
service "web.gnu."  on port 80 to it’s server running locally on port
8080 by having the following lines in the ‘gnunet.conf’ configuration
file:

     [web.gnunet.]
     TCP_REDIRECTS = 80:localhost4:8080


File: gnunet.info,  Node: A AAAA and TXT,  Next: CNAME,  Prev: VPN,  Up: Resource Records in GNS

4.7.6.6 A AAAA and TXT
......................

Those records work in exactly the same fashion as in traditional DNS.


File: gnunet.info,  Node: CNAME,  Next: GNS2DNS,  Prev: A AAAA and TXT,  Up: Resource Records in GNS

4.7.6.7 CNAME
.............

As specified in RFC 1035 whenever a CNAME is encountered the query needs
to be restarted with the specified name.  In GNS a CNAME can either be:

   • A zone relative name,
   • A zkey name or
   • A DNS name (in which case resolution will continue outside of GNS
     with the systems DNS resolver)


File: gnunet.info,  Node: GNS2DNS,  Next: SOA SRV PTR and MX,  Prev: CNAME,  Up: Resource Records in GNS

4.7.6.8 GNS2DNS
...............

GNS can delegate authority to a legacy DNS zone.  For this, the name of
the DNS nameserver and the name of the DNS zone are specified in a
GNS2DNS record.

   Example

     Name: pet; RRType: GNS2DNS; Value: gnunet.org@a.ns.joker.com

Any query to ‘pet.gnu’ will then be delegated to the DNS server at
‘a.ns.joker.com’.  For example, ‘www.pet.gnu (http://www.pet.gnu/)’ will
result in a DNS query for ‘www.gnunet.org (http://www.gnunet.org/)’ to
the server at ‘a.ns.joker.com’.  Delegation to DNS via NS records in GNS
can be useful if you do not want to start resolution in the DNS root
zone (due to issues such as censorship or availability).

   Note that you would typically want to use a relative name for the
nameserver, i.e.

     Name: pet; RRType: GNS2DNS; Value: gnunet.org@ns-joker.+ Name: ns-joker; RRType: A; Value: 184.172.157.218

This way, you can avoid involving the DNS hierarchy in the resolution of
‘a.ns.joker.com’.  In the example above, the problem may not be obvious
as the nameserver for "gnunet.org" is in the ".com" zone.  However,
imagine the nameserver was "ns.gnunet.org".  In this case, delegating to
"ns.gnunet.org" would mean that despite using GNS, censorship in the DNS
".org" zone would still be effective.


File: gnunet.info,  Node: SOA SRV PTR and MX,  Prev: GNS2DNS,  Up: Resource Records in GNS

4.7.6.9 SOA SRV PTR and MX
..........................

The domain names in those records can, again, be either

   • A zone relative name,
   • A zkey name or
   • A DNS name

   The resolver will expand the zone relative name if possible.  Note
that when using MX records within GNS, the target mail server might
still refuse to accept e-mails to the resulting domain as the name might
not match.  GNS-enabled mail clients should use the ZKEY zone as the
destination hostname and GNS-enabled mail servers should be configured
to accept e-mails to the ZKEY-zones of all local users.


File: gnunet.info,  Node: Synchronizing with legacy DNS,  Prev: Resource Records in GNS,  Up: The GNU Name System

4.7.7 Synchronizing with legacy DNS
-----------------------------------

If you want to support GNS but the master database for a zone is only
available and maintained in DNS, GNUnet includes the ‘gnunet-zoneimport’
tool to monitor a DNS zone and automatically import records into GNS.
Today, the tool does not yet support DNS AF(X)R, as we initially used it
on the “.fr” zone which does not allow us to perform a DNS zone
transfer.  Instead, ‘gnunet-zoneimport’ reads a list of DNS domain names
from ‘stdin’, issues DNS queries for each, converts the obtained records
(if possible) and stores the result in the namestore.

 [image src="images/gns.jpg" alt="picture of DNS-GNS data flow" ]

   The zonemaster service then takes the records from the namestore,
publishes them into the DHT which makes the result available to the GNS
resolver.  In the GNS configuration, non-local zones can be configured
to be intercepted by specifying “.tld = PUBLICKEY” in the configuration
file in the “[gns]” section.

   Note that the namestore by default also populates the namecache.
This pre-population is cryptographically expensive.  Thus, on systems
that only serve to import a large (millions of records) DNS zone and
that do not have a local gns service in use, it is thus advisable to
disable the namecache by setting the option “DISABLE” to “YES” in
section “[namecache]”.


File: gnunet.info,  Node: Using the Virtual Public Network,  Prev: The GNU Name System,  Up: Using GNUnet

4.8 Using the Virtual Public Network
====================================

* Menu:

* Setting up an Exit node::
* Fedora and the Firewall::
* Setting up VPN node for protocol translation and tunneling::

Using the GNUnet Virtual Public Network (VPN) application you can tunnel
IP traffic over GNUnet.  Moreover, the VPN comes with built-in protocol
translation and DNS-ALG support, enabling IPv4-to-IPv6 protocol
translation (in both directions).  This chapter documents how to use the
GNUnet VPN.

   The first thing to note about the GNUnet VPN is that it is a public
network.  All participating peers can participate and there is no secret
key to control access.  So unlike common virtual private networks, the
GNUnet VPN is not useful as a means to provide a "private" network
abstraction over the Internet.  The GNUnet VPN is a virtual network in
the sense that it is an overlay over the Internet, using its own routing
mechanisms and can also use an internal addressing scheme.  The GNUnet
VPN is an Internet underlay — TCP/IP applications run on top of it.

   The VPN is currently only supported on GNU/Linux systems.  Support
for operating systems that support TUN (such as FreeBSD) should be easy
to add (or might not even require any coding at all — we just did not
test this so far).  Support for other operating systems would require
re-writing the code to create virtual network interfaces and to
intercept DNS requests.

   The VPN does not provide good anonymity.  While requests are routed
over the GNUnet network, other peers can directly see the source and
destination of each (encapsulated) IP packet.  Finally, if you use the
VPN to access Internet services, the peer sending the request to the
Internet will be able to observe and even alter the IP traffic.  We will
discuss additional security implications of using the VPN later in this
chapter.


File: gnunet.info,  Node: Setting up an Exit node,  Next: Fedora and the Firewall,  Up: Using the Virtual Public Network

4.8.1 Setting up an Exit node
-----------------------------

Any useful operation with the VPN requires the existence of an exit node
in the GNUnet Peer-to-Peer network.  Exit functionality can only be
enabled on peers that have regular Internet access.  If you want to play
around with the VPN or support the network, we encourage you to setup
exit nodes.  This chapter documents how to setup an exit node.

   There are four types of exit functions an exit node can provide, and
using the GNUnet VPN to access the Internet will only work nicely if the
first three types are provided somewhere in the network.  The four exit
functions are:

   • DNS: allow other peers to use your DNS resolver
   • IPv4: allow other peers to access your IPv4 Internet connection
   • IPv6: allow other peers to access your IPv6 Internet connection
   • Local service: allow other peers to access a specific TCP or UDP
     service your peer is providing

   By enabling "exit" in gnunet-setup and checking the respective boxes
in the "exit" tab, you can easily choose which of the above exit
functions you want to support.

   Note, however, that by supporting the first three functions you will
allow arbitrary other GNUnet users to access the Internet via your
system.  This is somewhat similar to running a Tor exit node.  The
Torproject has a nice article about what to consider if you want to do
this here.  We believe that generally running a DNS exit node is
completely harmless.

   The exit node configuration does currently not allow you to restrict
the Internet traffic that leaves your system.  In particular, you cannot
exclude SMTP traffic (or block port 25) or limit to HTTP traffic using
the GNUnet configuration.  However, you can use your host firewall to
restrict outbound connections from the virtual tunnel interface.  This
is highly recommended.  In the future, we plan to offer a wider range of
configuration options for exit nodes.

   Note that by running an exit node GNUnet will configure your kernel
to perform IP-forwarding (for IPv6) and NAT (for IPv4) so that the
traffic from the virtual interface can be routed to the Internet.  In
order to provide an IPv6-exit, you need to have a subnet routed to your
host’s external network interface and assign a subrange of that subnet
to the GNUnet exit’s TUN interface.

   When running a local service, you should make sure that the local
service is (also) bound to the IP address of your EXIT interface (i.e.
169.254.86.1).  It will NOT work if your local service is just bound to
loopback.  You may also want to create a "VPN" record in your zone of
the GNU Name System to make it easy for others to access your service
via a name instead of just the full service descriptor.  Note that the
identifier you assign the service can serve as a passphrase or shared
secret, clients connecting to the service must somehow learn the
service’s name.  VPN records in the GNU Name System can make this
easier.


File: gnunet.info,  Node: Fedora and the Firewall,  Next: Setting up VPN node for protocol translation and tunneling,  Prev: Setting up an Exit node,  Up: Using the Virtual Public Network

4.8.2 Fedora and the Firewall
-----------------------------

When using an exit node on Fedora 15, the standard firewall can create
trouble even when not really exiting the local system!  For IPv4, the
standard rules seem fine.  However, for IPv6 the standard rules prohibit
traffic from the network range of the virtual interface created by the
exit daemon to the local IPv6 address of the same interface (which is
essentially loopback traffic, so you might suspect that a standard
firewall would leave this traffic alone).  However, as somehow for IPv6
the traffic is not recognized as originating from the local system (and
as the connection is not already "established"), the firewall drops the
traffic.  You should still get ICMPv6 packets back, but that’s obviously
not very useful.

   Possible ways to fix this include disabling the firewall (do you have
a good reason for having it on?)  or disabling the firewall at least for
the GNUnet exit interface (or the respective IPv4/IPv6 address range).
The best way to diagnose these kinds of problems in general involves
setting the firewall to REJECT instead of DROP and to watch the traffic
using wireshark (or tcpdump) to see if ICMP messages are generated when
running some tests that should work.


File: gnunet.info,  Node: Setting up VPN node for protocol translation and tunneling,  Prev: Fedora and the Firewall,  Up: Using the Virtual Public Network

4.8.3 Setting up VPN node for protocol translation and tunneling
----------------------------------------------------------------

The GNUnet VPN/PT subsystem enables you to tunnel IP traffic over the
VPN to an exit node, from where it can then be forwarded to the
Internet.  This section documents how to setup VPN/PT on a node.  Note
that you can enable both the VPN and an exit on the same peer.  In this
case, IP traffic from your system may enter your peer’s VPN and leave
your peer’s exit.  This can be useful as a means to do protocol
translation.  For example, you might have an application that supports
only IPv4 but needs to access an IPv6-only site.  In this case, GNUnet
would perform 4to6 protocol translation between the VPN (IPv4) and the
Exit (IPv6).  Similarly, 6to4 protocol translation is also possible.
However, the primary use for GNUnet would be to access an Internet
service running with an IP version that is not supported by your ISP. In
this case, your IP traffic would be routed via GNUnet to a peer that has
access to the Internet with the desired IP version.

   Setting up an entry node into the GNUnet VPN primarily requires you
to enable the "VPN/PT" option in "gnunet-setup".  This will launch the
"gnunet-service-vpn", "gnunet-service-dns" and "gnunet-daemon-pt"
processes.  The "gnunet-service-vpn" will create a virtual interface
which will be used as the target for your IP traffic that enters the
VPN. Additionally, a second virtual interface will be created by the
"gnunet-service-dns" for your DNS traffic.  You will then need to
specify which traffic you want to tunnel over GNUnet.  If your ISP only
provides you with IPv4 or IPv6-access, you may choose to tunnel the
other IP protocol over the GNUnet VPN. If you do not have an ISP (and
are connected to other GNUnet peers via WLAN), you can also choose to
tunnel all IP traffic over GNUnet.  This might also provide you with
some anonymity.  After you enable the respective options and restart
your peer, your Internet traffic should be tunneled over the GNUnet VPN.

   The GNUnet VPN uses DNS-ALG to hijack your IP traffic.  Whenever an
application resolves a hostname (i.e.  ’gnunet.org’), the
"gnunet-daemon-pt" will instruct the "gnunet-service-dns" to intercept
the request (possibly route it over GNUnet as well) and replace the
normal answer with an IP in the range of the VPN’s interface.
"gnunet-daemon-pt" will then tell "gnunet-service-vpn" to forward all
traffic it receives on the TUN interface via the VPN to the original
destination.

   For applications that do not use DNS, you can also manually create
such a mapping using the gnunet-vpn command-line tool.  Here, you
specfiy the desired address family of the result (i.e.  "-4"), and the
intended target IP on the Internet ("-i 131.159.74.67") and "gnunet-vpn"
will tell you which IP address in the range of your VPN tunnel was
mapped.

   ‘gnunet-vpn’ can also be used to access "internal" services offered
by GNUnet nodes.  So if you happen to know a peer and a service offered
by that peer, you can create an IP tunnel to that peer by specifying the
peer’s identity, service name and protocol (–tcp or –udp) and you will
again receive an IP address that will terminate at the respective peer’s
service.


File: gnunet.info,  Node: GNUnet Contributors Handbook,  Next: GNUnet Developer Handbook,  Prev: Using GNUnet,  Up: Top

5 GNUnet Contributors Handbook
******************************

* Menu:

* Contributing to GNUnet::
* Licenses of contributions::
* Copyright Assignment::
* Contributing to the Reference Manual::


File: gnunet.info,  Node: Contributing to GNUnet,  Next: Licenses of contributions,  Up: GNUnet Contributors Handbook

5.1 Contributing to GNUnet
==========================


File: gnunet.info,  Node: Licenses of contributions,  Next: Copyright Assignment,  Prev: Contributing to GNUnet,  Up: GNUnet Contributors Handbook

5.2 Licenses of contributions
=============================

GNUnet is a GNU (https://www.gnu.org/) package.  All code contributions
must thus be put under the GNU Public License (GPL)
(https://www.gnu.org/copyleft/gpl.html).  All documentation should be
put under FSF approved licenses (see fdl
(https://www.gnu.org/copyleft/fdl.html)).

   By submitting documentation, translations, and other content to
GNUnet you automatically grant the right to publish code under the GNU
Public License and documentation under either or both the GNU Public
License or the GNU Free Documentation License.  When contributing to the
GNUnet project, GNU standards and the GNU philosophy
(https://www.gnu.org/philosophy/philosophy.html) should be adhered to.


File: gnunet.info,  Node: Copyright Assignment,  Next: Contributing to the Reference Manual,  Prev: Licenses of contributions,  Up: GNUnet Contributors Handbook

5.3 Copyright Assignment
========================

We require a formal copyright assignment for GNUnet contributors to
GNUnet e.V.; nevertheless, we do allow pseudonymous contributions.  By
signing the copyright agreement and submitting your code (or
documentation) to us, you agree to share the rights to your code with
GNUnet e.V.; GNUnet e.V. receives non-exclusive ownership rights, and in
particular is allowed to dual-license the code.  You retain
non-exclusive rights to your contributions, so you can also share your
contributions freely with other projects.

   GNUnet e.V. will publish all accepted contributions under the GPLv3
or any later version.  The association may decide to publish
contributions under additional licenses (dual-licensing).

   We do not intentionally remove your name from your contributions;
however, due to extensive editing it is not always trivial to attribute
contributors properly.  If you find that you significantly contributed
to a file (or the project as a whole) and are not listed in the
respective authors file or section, please do let us know.


File: gnunet.info,  Node: Contributing to the Reference Manual,  Prev: Copyright Assignment,  Up: GNUnet Contributors Handbook

5.4 Contributing to the Reference Manual
========================================

   • When writing documentation, please use gender-neutral wording
     (https://en.wikipedia.org/wiki/Singular_they) when referring to
     people, such as singular “they”, “their”, “them”, and so forth.

   • Keep line length below 74 characters, except for URLs.  URLs break
     in the PDF output when they contain linebreaks.

   • Do not use tab characters (see chapter 2.1 texinfo manual)

   • Write texts in the third person perspective.

   • Use @footnote{} instead of putting an @*ref{} to the footnote on a
     collected footnote-page.  In a 200+ pages handbook it’s better to
     have footnotes accessible without having to skip over to the end.


File: gnunet.info,  Node: GNUnet Developer Handbook,  Next: GNU Free Documentation License,  Prev: GNUnet Contributors Handbook,  Up: Top

6 GNUnet Developer Handbook
***************************

This book is intended to be an introduction for programmers that want to
extend the GNUnet framework.  GNUnet is more than a simple peer-to-peer
application.

   For developers, GNUnet is:

   • developed by a community that believes in the GNU philosophy
   • Free Software (Free as in Freedom), licensed under the GNU General
     Public License(1)
   • A set of standards, including coding conventions and architectural
     rules
   • A set of layered protocols, both specifying the communication
     between peers as well as the communication between components of a
     single peer
   • A set of libraries with well-defined APIs suitable for writing
     extensions

   In particular, the architecture specifies that a peer consists of
many processes communicating via protocols.  Processes can be written in
almost any language.  ‘C’, ‘Java’ and ‘Guile’ APIs exist for accessing
existing services and for writing extensions.  It is possible to write
extensions in other languages by implementing the necessary IPC
protocols.

   GNUnet can be extended and improved along many possible dimensions,
and anyone interested in Free Software and Freedom-enhancing Networking
is welcome to join the effort.  This Developer Handbook attempts to
provide an initial introduction to some of the key design choices and
central components of the system.  This part of the GNUNet documentation
is far from complete, and we welcome informed contributions, be it in
the form of new chapters, sections or insightful comments.

* Menu:

* Developer Introduction::
* Code overview::
* System Architecture::
* Subsystem stability::
* Naming conventions and coding style guide::
* Build-system::
* Developing extensions for GNUnet using the gnunet-ext template::
* Writing testcases::
* TESTING library::
* Performance regression analysis with Gauger::
* TESTBED Subsystem::
* libgnunetutil::
* Automatic Restart Manager (ARM)::
* TRANSPORT Subsystem::
* NAT library::
* Distance-Vector plugin::
* SMTP plugin::
* Bluetooth plugin::
* WLAN plugin::
* ATS Subsystem::
* CORE Subsystem::
* CADET Subsystem::
* NSE Subsystem::
* HOSTLIST Subsystem::
* IDENTITY Subsystem::
* NAMESTORE Subsystem::
* PEERINFO Subsystem::
* PEERSTORE Subsystem::
* SET Subsystem::
* STATISTICS Subsystem::
* Distributed Hash Table (DHT)::
* GNU Name System (GNS)::
* GNS Namecache::
* REVOCATION Subsystem::
* File-sharing (FS) Subsystem::
* REGEX Subsystem::
* REST Subsystem::

   ---------- Footnotes ----------

   (1) https://www.gnu.org/licenses/licenses.html#GPL
(https://www.gnu.org/licenses/licenses.html#GPL)


File: gnunet.info,  Node: Developer Introduction,  Next: Code overview,  Up: GNUnet Developer Handbook

6.1 Developer Introduction
==========================

This Developer Handbook is intended as first introduction to GNUnet for
new developers that want to extend the GNUnet framework.  After the
introduction, each of the GNUnet subsystems (directories in the ‘src/’
tree) is (supposed to be) covered in its own chapter.  In addition to
this documentation, GNUnet developers should be aware of the services
available on the GNUnet server to them.

   New developers can have a look a the GNUnet tutorials for C and java
available in the ‘src/’ directory of the repository or under the
following links:

   • *Note Introduction: (gnunet-c-tutorial)Top.
   • GNUnet Java tutorial

   In addition to the GNUnet Reference Documentation you are reading,
the GNUnet server at <https://gnunet.org> contains various resources for
GNUnet developers and those who aspire to become regular contributors.
They are all conveniently reachable via the "Developer" entry in the
navigation menu.  Some additional tools (such as static analysis
reports) require a special developer access to perform certain
operations.  If you want (or require) access, you should contact
Christian Grothoff (http://grothoff.org/christian/), GNUnet’s
maintainer.

   The public subsystems on the GNUnet server that help developers are:

   • The version control system (git) keeps our code and enables
     distributed development.  It is publicly accessible at
     <https://gnunet.org/git/>.  Only developers with write access can
     commit code, everyone else is encouraged to submit patches to the
     GNUnet-developers mailinglist:
     https://lists.gnu.org/mailman/listinfo/gnunet-developers
     (https://lists.gnu.org/mailman/listinfo/gnunet-developers)

   • The bugtracking system (Mantis).  We use it to track feature
     requests, open bug reports and their resolutions.  It can be
     accessed at https://gnunet.org/bugs/ (https://gnunet.org/bugs/).
     Anyone can report bugs.

   • Our site installation of the CI(1) system ‘Buildbot’ is used to
     check GNUnet builds automatically on a range of platforms.  The web
     interface of this CI is exposed at https://gnunet.org/buildbot/
     (https://gnunet.org/buildbot/).  Builds are triggered automatically
     30 minutes after the last commit to our repository was made.

   • The current quality of our automated test suite is assessed using
     Code coverage analysis.  This analysis is run daily; however the
     webpage is only updated if all automated tests pass at that time.
     Testcases that improve our code coverage are always welcome.

   • We try to automatically find bugs using a static analysis scan.
     This scan is run daily; however the webpage is only updated if all
     automated tests pass at the time.  Note that not everything that is
     flagged by the analysis is a bug, sometimes even good code can be
     marked as possibly problematic.  Nevertheless, developers are
     encouraged to at least be aware of all issues in their code that
     are listed.

   • We use Gauger for automatic performance regression visualization.
     Details on how to use Gauger are here.

   • We use junit (http://junit.org/) to automatically test
     ‘gnunet-java’.  Automatically generated, current reports on the
     test suite are here.

   • We use Cobertura to generate test coverage reports for gnunet-java.
     Current reports on test coverage are here.

* Menu:

* Project overview::

   ---------- Footnotes ----------

   (1) Continuous Integration


File: gnunet.info,  Node: Project overview,  Up: Developer Introduction

6.1.1 Project overview
----------------------

The GNUnet project consists at this point of several sub-projects.  This
section is supposed to give an initial overview about the various
sub-projects.  Note that this description also lists projects that are
far from complete, including even those that have literally not a single
line of code in them yet.

   GNUnet sub-projects in order of likely relevance are currently:

‘gnunet’
     Core of the P2P framework, including file-sharing, VPN and chat
     applications; this is what the Developer Handbook covers mostly
‘gnunet-gtk’
     Gtk+-based user interfaces, including:

        • ‘gnunet-fs-gtk’ (file-sharing),
        • ‘gnunet-statistics-gtk’ (statistics over time),
        • ‘gnunet-peerinfo-gtk’ (information about current connections
          and known peers),
        • ‘gnunet-chat-gtk’ (chat GUI) and
        • ‘gnunet-setup’ (setup tool for "everything")

‘gnunet-fuse’
     Mounting directories shared via GNUnet’s file-sharing on GNU/Linux
     distributions
‘gnunet-update’
     Installation and update tool
‘gnunet-ext’
     Template for starting ’external’ GNUnet projects
‘gnunet-java’
     Java APIs for writing GNUnet services and applications
‘eclectic’
     Code to run GNUnet nodes on testbeds for research, development,
     testing and evaluation
‘gnunet-qt’
     Qt-based GNUnet GUI (is it deprecated?)
‘gnunet-cocoa’
     cocoa-based GNUnet GUI (is it deprecated?)
‘gnunet-guile’
     Guile bindings for GNUnet

   We are also working on various supporting libraries and tools:

‘libextractor’
     GNU libextractor (meta data extraction)
‘libmicrohttpd’
     GNU libmicrohttpd (embedded HTTP(S) server library)
‘gauger’
     Tool for performance regression analysis
‘monkey’
     Tool for automated debugging of distributed systems
‘libmwmodem’
     Library for accessing satellite connection quality reports
‘libgnurl’
     gnURL (feature-restricted variant of cURL/libcurl)

   Finally, there are various external projects (see links for a list of
those that have a public website) which build on top of the GNUnet
framework.


File: gnunet.info,  Node: Code overview,  Next: System Architecture,  Prev: Developer Introduction,  Up: GNUnet Developer Handbook

6.2 Code overview
=================

This section gives a brief overview of the GNUnet source code.
Specifically, we sketch the function of each of the subdirectories in
the ‘gnunet/src/’ directory.  The order given is roughly bottom-up (in
terms of the layers of the system).

‘util/’ — libgnunetutil
     Library with general utility functions, all GNUnet binaries link
     against this library.  Anything from memory allocation and data
     structures to cryptography and inter-process communication.  The
     goal is to provide an OS-independent interface and more ’secure’ or
     convenient implementations of commonly used primitives.  The API is
     spread over more than a dozen headers, developers should study
     those closely to avoid duplicating existing functions.  *note
     libgnunetutil::.
‘hello/’ — libgnunethello
     HELLO messages are used to describe under which addresses a peer
     can be reached (for example, protocol, IP, port).  This library
     manages parsing and generating of HELLO messages.
‘block/’ — libgnunetblock
     The DHT and other components of GNUnet store information in units
     called ’blocks’.  Each block has a type and the type defines a
     particular format and how that binary format is to be linked to a
     hash code (the key for the DHT and for databases).  The block
     library is a wapper around block plugins which provide the
     necessary functions for each block type.
‘statistics/’ — statistics service
     The statistics service enables associating values (of type
     uint64_t) with a component name and a string.  The main uses is
     debugging (counting events), performance tracking and user
     entertainment (what did my peer do today?).
‘arm/’ — Automatic Restart Manager (ARM)
     The automatic-restart-manager (ARM) service is the GNUnet master
     service.  Its role is to start gnunet-services, to re-start them
     when they crashed and finally to shut down the system when
     requested.
‘peerinfo/’ — peerinfo service
     The peerinfo service keeps track of which peers are known to the
     local peer and also tracks the validated addresses for each peer
     (in the form of a HELLO message) for each of those peers.  The peer
     is not necessarily connected to all peers known to the peerinfo
     service.  Peerinfo provides persistent storage for peer identities
     — peers are not forgotten just because of a system restart.
‘datacache/’ — libgnunetdatacache
     The datacache library provides (temporary) block storage for the
     DHT. Existing plugins can store blocks in Sqlite, Postgres or MySQL
     databases.  All data stored in the cache is lost when the peer is
     stopped or restarted (datacache uses temporary tables).
‘datastore/’ — datastore service
     The datastore service stores file-sharing blocks in databases for
     extended periods of time.  In contrast to the datacache, data is
     not lost when peers restart.  However, quota restrictions may still
     cause old, expired or low-priority data to be eventually discarded.
     Existing plugins can store blocks in Sqlite, Postgres or MySQL
     databases.
‘template/’ — service template
     Template for writing a new service.  Does nothing.
‘ats/’ — Automatic Transport Selection
     The automatic transport selection (ATS) service is responsible for
     deciding which address (i.e.  which transport plugin) should be
     used for communication with other peers, and at what bandwidth.
‘nat/’ — libgnunetnat
     Library that provides basic functions for NAT traversal.  The
     library supports NAT traversal with manual hole-punching by the
     user, UPnP and ICMP-based autonomous NAT traversal.  The library
     also includes an API for testing if the current configuration works
     and the ‘gnunet-nat-server’ which provides an external service to
     test the local configuration.
‘fragmentation/’ — libgnunetfragmentation
     Some transports (UDP and WLAN, mostly) have restrictions on the
     maximum transfer unit (MTU) for packets.  The fragmentation library
     can be used to break larger packets into chunks of at most 1k and
     transmit the resulting fragments reliabily (with acknowledgement,
     retransmission, timeouts, etc.).
‘transport/’ — transport service
     The transport service is responsible for managing the basic P2P
     communication.  It uses plugins to support P2P communication over
     TCP, UDP, HTTP, HTTPS and other protocols.The transport service
     validates peer addresses, enforces bandwidth restrictions, limits
     the total number of connections and enforces connectivity
     restrictions (i.e.  friends-only).
‘peerinfo-tool/’ — gnunet-peerinfo
     This directory contains the gnunet-peerinfo binary which can be
     used to inspect the peers and HELLOs known to the peerinfo service.
‘core/’
     The core service is responsible for establishing encrypted,
     authenticated connections with other peers, encrypting and
     decrypting messages and forwarding messages to higher-level
     services that are interested in them.
‘testing/’ — libgnunettesting
     The testing library allows starting (and stopping) peers for
     writing testcases.  It also supports automatic generation of
     configurations for peers ensuring that the ports and paths are
     disjoint.  libgnunettesting is also the foundation for the testbed
     service
‘testbed/’ — testbed service
     The testbed service is used for creating small or large scale
     deployments of GNUnet peers for evaluation of protocols.  It
     facilitates peer depolyments on multiple hosts (for example, in a
     cluster) and establishing varous network topologies (both underlay
     and overlay).
‘nse/’ — Network Size Estimation
     The network size estimation (NSE) service implements a protocol for
     (securely) estimating the current size of the P2P network.
‘dht/’ — distributed hash table
     The distributed hash table (DHT) service provides a distributed
     implementation of a hash table to store blocks under hash keys in
     the P2P network.
‘hostlist/’ — hostlist service
     The hostlist service allows learning about other peers in the
     network by downloading HELLO messages from an HTTP server, can be
     configured to run such an HTTP server and also implements a P2P
     protocol to advertise and automatically learn about other peers
     that offer a public hostlist server.
‘topology/’ — topology service
     The topology service is responsible for maintaining the mesh
     topology.  It tries to maintain connections to friends (depending
     on the configuration) and also tries to ensure that the peer has a
     decent number of active connections at all times.  If necessary,
     new connections are added.  All peers should run the topology
     service, otherwise they may end up not being connected to any other
     peer (unless some other service ensures that core establishes the
     required connections).  The topology service also tells the
     transport service which connections are permitted (for
     friend-to-friend networking)
‘fs/’ — file-sharing
     The file-sharing (FS) service implements GNUnet’s file-sharing
     application.  Both anonymous file-sharing (using gap) and
     non-anonymous file-sharing (using dht) are supported.
‘cadet/’ — cadet service
     The CADET service provides a general-purpose routing abstraction to
     create end-to-end encrypted tunnels in mesh networks.  We wrote a
     paper documenting key aspects of the design.
‘tun/’ — libgnunettun
     Library for building IPv4, IPv6 packets and creating checksums for
     UDP, TCP and ICMP packets.  The header defines C structs for common
     Internet packet formats and in particular structs for interacting
     with TUN (virtual network) interfaces.
‘mysql/’ — libgnunetmysql
     Library for creating and executing prepared MySQL statements and to
     manage the connection to the MySQL database.  Essentially a
     lightweight wrapper for the interaction between GNUnet components
     and libmysqlclient.
‘dns/’
     Service that allows intercepting and modifying DNS requests of the
     local machine.  Currently used for IPv4-IPv6 protocol translation
     (DNS-ALG) as implemented by "pt/" and for the GNUnet naming system.
     The service can also be configured to offer an exit service for DNS
     traffic.
‘vpn/’ — VPN service
     The virtual public network (VPN) service provides a virtual tunnel
     interface (VTUN) for IP routing over GNUnet.  Needs some other
     peers to run an "exit" service to work.  Can be activated using the
     "gnunet-vpn" tool or integrated with DNS using the "pt" daemon.
‘exit/’
     Daemon to allow traffic from the VPN to exit this peer to the
     Internet or to specific IP-based services of the local peer.
     Currently, an exit service can only be restricted to IPv4 or IPv6,
     not to specific ports and or IP address ranges.  If this is not
     acceptable, additional firewall rules must be added manually.  exit
     currently only works for normal UDP, TCP and ICMP traffic; DNS
     queries need to leave the system via a DNS service.
‘pt/’
     protocol translation daemon.  This daemon enables 4-to-6, 6-to-4,
     4-over-6 or 6-over-4 transitions for the local system.  It
     essentially uses "DNS" to intercept DNS replies and then maps
     results to those offered by the VPN, which then sends them using
     mesh to some daemon offering an appropriate exit service.
‘identity/’
     Management of egos (alter egos) of a user; identities are
     essentially named ECC private keys and used for zones in the GNU
     name system and for namespaces in file-sharing, but might find
     other uses later
‘revocation/’
     Key revocation service, can be used to revoke the private key of an
     identity if it has been compromised
‘namecache/’
     Cache for resolution results for the GNU name system; data is
     encrypted and can be shared among users, loss of the data should
     ideally only result in a performance degradation (persistence not
     required)
‘namestore/’
     Database for the GNU name system with per-user private information,
     persistence required
‘gns/’
     GNU name system, a GNU approach to DNS and PKI.
‘dv/’
     A plugin for distance-vector (DV)-based routing.  DV consists of a
     service and a transport plugin to provide peers with the illusion
     of a direct P2P connection for connections that use multiple
     (typically up to 3) hops in the actual underlay network.
‘regex/’
     Service for the (distributed) evaluation of regular expressions.
‘scalarproduct/’
     The scalar product service offers an API to perform a secure
     multiparty computation which calculates a scalar product between
     two peers without exposing the private input vectors of the peers
     to each other.
‘consensus/’
     The consensus service will allow a set of peers to agree on a set
     of values via a distributed set union computation.
‘rest/’
     The rest API allows access to GNUnet services using RESTful
     interaction.  The services provide plugins that can exposed by the
     rest server.


File: gnunet.info,  Node: System Architecture,  Next: Subsystem stability,  Prev: Code overview,  Up: GNUnet Developer Handbook

6.3 System Architecture
=======================

GNUnet developers like LEGOs.  The blocks are indestructible, can be
stacked together to construct complex buildings and it is generally easy
to swap one block for a different one that has the same shape.  GNUnet’s
architecture is based on LEGOs:

   This chapter documents the GNUnet LEGO system, also known as GNUnet’s
system architecture.

   The most common GNUnet component is a service.  Services offer an API
(or several, depending on what you count as "an API") which is
implemented as a library.  The library communicates with the main
process of the service using a service-specific network protocol.  The
main process of the service typically doesn’t fully provide everything
that is needed — it has holes to be filled by APIs to other services.

   A special kind of component in GNUnet are user interfaces and
daemons.  Like services, they have holes to be filled by APIs of other
services.  Unlike services, daemons do not implement their own network
protocol and they have no API:

   The GNUnet system provides a range of services, daemons and user
interfaces, which are then combined into a layered GNUnet instance (also
known as a peer).

   Note that while it is generally possible to swap one service for
another compatible service, there is often only one implementation.
However, during development we often have a "new" version of a service
in parallel with an "old" version.  While the "new" version is not
working, developers working on other parts of the service can continue
their development by simply using the "old" service.  Alternative design
ideas can also be easily investigated by swapping out individual
components.  This is typically achieved by simply changing the name of
the "BINARY" in the respective configuration section.

   Key properties of GNUnet services are that they must be separate
processes and that they must protect themselves by applying tight error
checking against the network protocol they implement (thereby achieving
a certain degree of robustness).

   On the other hand, the APIs are implemented to tolerate failures of
the service, isolating their host process from errors by the service.
If the service process crashes, other services and daemons around it
should not also fail, but instead wait for the service process to be
restarted by ARM.


File: gnunet.info,  Node: Subsystem stability,  Next: Naming conventions and coding style guide,  Prev: System Architecture,  Up: GNUnet Developer Handbook

6.4 Subsystem stability
=======================

This section documents the current stability of the various GNUnet
subsystems.  Stability here describes the expected degree of
compatibility with future versions of GNUnet.  For each subsystem we
distinguish between compatibility on the P2P network level
(communication protocol between peers), the IPC level (communication
between the service and the service library) and the API level
(stability of the API). P2P compatibility is relevant in terms of which
applications are likely going to be able to communicate with future
versions of the network.  IPC communication is relevant for the
implementation of language bindings that re-implement the IPC messages.
Finally, API compatibility is relevant to developers that hope to be
able to avoid changes to applications build on top of the APIs of the
framework.

   The following table summarizes our current view of the stability of
the respective protocols or APIs:

Subsystem      P2P            IPC            C API
------------------------------------------------------------
util           n/a            n/a            stable
arm            n/a            stable         stable
ats            n/a            unstable       testing
block          n/a            n/a            stable
cadet          testing        testing        testing
consensus      experimental   experimental   experimental
core           stable         stable         stable
datacache      n/a            n/a            stable
datastore      n/a            stable         stable
dht            stable         stable         stable
dns            stable         stable         stable
dv             testing        testing        n/a
exit           testing        n/a            n/a
fragmentation  stable         n/a            stable
fs             stable         stable         stable
gns            stable         stable         stable
hello          n/a            n/a            testing
hostlist       stable         stable         n/a
identity       stable         stable         n/a
multicast      experimental   experimental   experimental
mysql          stable         n/a            stable
namestore      n/a            stable         stable
nat            n/a            n/a            stable
nse            stable         stable         stable
peerinfo       n/a            stable         stable
psyc           experimental   experimental   experimental
pt             n/a            n/a            n/a
regex          stable         stable         stable
revocation     stable         stable         stable
social         experimental   experimental   experimental
statistics     n/a            stable         stable
testbed        n/a            testing        testing
testing        n/a            n/a            testing
topology       n/a            n/a            n/a
transport      stable         stable         stable
tun            n/a            n/a            stable
vpn            testing        n/a            n/a

   Here is a rough explanation of the values:

‘stable’
     No incompatible changes are planned at this time; for IPC/APIs, if
     there are incompatible changes, they will be minor and might only
     require minimal changes to existing code; for P2P, changes will be
     avoided if at all possible for the 0.10.x-series

‘testing’
     No incompatible changes are planned at this time, but the code is
     still known to be in flux; so while we have no concrete plans, our
     expectation is that there will still be minor modifications; for
     P2P, changes will likely be extensions that should not break
     existing code

‘unstable’
     Changes are planned and will happen; however, they will not be
     totally radical and the result should still resemble what is there
     now; nevertheless, anticipated changes will break protocol/API
     compatibility

‘experimental’
     Changes are planned and the result may look nothing like what the
     API/protocol looks like today

‘unknown’
     Someone should think about where this subsystem headed

‘n/a’
     This subsystem does not have an API/IPC-protocol/P2P-protocol

